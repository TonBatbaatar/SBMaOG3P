Number IO,"Given an integer and a float, return their sum.","Write a python function using given grammar without comment, explanation, example usage. Function parameter name has to be in0, in1...(depends on how many parameter it needs), and return variable name has to be res0, res1...(depends on how many parameter it needs).
problem description: Given an integer and a float, return their sum.
problem grammar: <predefined> ::= ""i0 = int(); i1 = int(); i2 = int()""
""f0 = float(); f1 = float(); f2 = float()""
""res0 = float()""
""if 'rec_counter' not in globals():{:""
""globals()['rec_counter'] = 0:}""
""global rec_counter""
<code>
<code> ::= <code><statement>'\n'|<statement>'\n'<code>|<code><statement>'\n'<code>|<statement>'\n'
<statement> ::= <simple_stmt>|<for>
<simple_stmt> ::= <call>|<assign>
<call> ::= 'if rec_counter < 900 and not stop.value:{:'
'rec_counter += 1'
<float_var>' = evolve('<int>', '<float>')'
'rec_counter -= 1'
':}'|'return res0'
<assign> ::= <int_assign>|<float_assign>
<for> ::= 'loopBreak% = 0\nfor forCounter% in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<number> ::= <number><num>|<num><number>|<number><num><number>|<num>
<num> ::= '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
<int_var> ::= 'i0'|'i1'|'i2'|'in0'
<int_assign> ::= <int_var>' = '<int>|<int_var>' '<arith_ops>'= '<int>
<int> ::= <int_var>|'int('<number>'.0)'|<arith_prefix><int>|'( '<int>' '<arith_ops>' '<int>' )'|<int_arith_ops_protected>'('<int>','<int>')'|'min('<int>', '<int>')'|'max('<int>', '<int>')'|'abs('<int>')'|'('<int>' + 1)'|'('<int>' - 1)'|'int(math.ceil('<float>'))'|'int(math.floor('<float>'))'|'int(round('<float>'))'|'int('<float>')'
<arith_ops> ::= '+'|'-'|'*'
<int_arith_ops_protected> ::= 'divInt'|'mod'
<arith_prefix> ::= '+'|'-'
<float> ::= <int>|<float_var>|<number>'.'<number>|<arith_prefix><float>|'('<float>' '<arith_ops>' '<float>')'|<float_arith_ops_protected>'('<float>','<float>')'|'math.ceil('<float>')'|'math.floor('<float>')'|'round('<float>')'|'min('<float>', '<float>')'|'max('<float>', '<float>')'|'abs('<float>')'|'math.sin('<float>')'|'math.cos('<float>')'|'math.tan('<float>')'|'('<float>' + 1)'|'('<float>' - 1)'
<float_var> ::= 'f0'|'f1'|'f2'|'res0'|'in1'
<float_assign> ::= <float_var>' = '<float>|<float_var>' '<arith_ops>'= '<float>
<float_arith_ops_protected> ::= 'div'|'divInt'|'mod'
"
Small Or Large,"Given an integer n, return “small” if n < 1000 and “large” if n ≥ 2000 (and nothing if 1000 ≤ n < 2000).","Write a python function using given grammar without comment, explanation, example usage. Function parameter name has to be in0, in1...(depends on how many parameter it needs), and return variable name has to be res0, res1...(depends on how many parameter it needs).
problem description: Given an integer n, return “small” if n < 1000 and “large” if n ≥ 2000 (and nothing if 1000 ≤ n < 2000).
problem grammar: <predefined> ::= ""i0 = int(); i1 = int(); i2 = int()""
""b0 = bool(); b1 = bool(); b2 = bool()""
""s0 = str(); s1 = str(); s2 = str()""
""res0 = str()""
""if 'rec_counter' not in globals():{:""
""globals()['rec_counter'] = 0:}""
""global rec_counter""
<code>
<code> ::= <code><statement>'\n'|<statement>'\n'<code>|<code><statement>'\n'<code>|<statement>'\n'
<statement> ::= <simple_stmt>|<compound_stmt>
<simple_stmt> ::= <call>|<assign>
<compound_stmt> ::= <for>|<if>|'loopBreak% = 0\nwhile '<bool>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<call> ::= 'if rec_counter < 900 and not stop.value:{:'
'rec_counter += 1'
<string_var>' = evolve('<int>')'
'rec_counter -= 1'
':}'|'return res0'
<assign> ::= <bool_var>' = '<bool>|<int_assign>|<string_var>' = '<string>
<for> ::= 'loopBreak% = 0\nfor forCounter% in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in '<string>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in '<string>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in '<string>'.strip().split():{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in saveSplit('<string>'.strip(), '<string>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<number> ::= <number><num>|<num><number>|<number><num><number>|<num>
<num> ::= '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
<comp_op> ::= '<'|'>'|'=='|'>='|'<='|'!='|'is'|'is not'
<string_const_part> ::= <string_const_part><string_literal>|<string_literal><string_const_part>|<string_const_part><string_literal><string_const_part>|<string_literal>
<bool_var> ::= 'b0'|'b1'|'b2'
<bool> ::= <bool_var>|<bool_const>|'(not '<bool>')'|'('<bool>' '<bool_op>' '<bool>')'|'( not '<bool>' and '<bool>')'|'('<bool>' and not '<bool>')'|'('<int>' '<comp_op>' '<int>')'|'bool('<int>')'|'('<string>' in '<string>')'|'('<string>' not in '<string>')'|'('<string>' == '<string>')'|'('<string>' != '<string>')'|<string>'.startswith('<string>')'|<string>'.endswith('<string>')'|'(not '<string>')'
<bool_op> ::= 'and'|'or'|'^'|'=='
<bool_const> ::= 'True'|'False'
<if> ::= 'if '<bool>':{:\n'<code>':}'|'if '<bool>':{:\n'<code>':}else:{:\n'<code>':}'
<int> ::= 'int('<bool>')'|<int_var>|'int('<number>'.0)'|<arith_prefix><int>|'( '<int>' '<arith_ops>' '<int>' )'|<int_arith_ops_protected>'('<int>','<int>')'|'min('<int>', '<int>')'|'max('<int>', '<int>')'|'abs('<int>')'|'('<int>' + 1)'|'('<int>' - 1)'|'len('<string>')'|<string>'.count('<char>')'|<string>'.count('<string>')'
<string> ::= 'str('<bool>')'|'str('<int>')'|<string_var>|<string_const>|<string_slice>|'('<string>' + '<string>')'|<string>'.lstrip()'|<string>'.rstrip()'|<string>'.strip()'|<string>'.lstrip('<string>')'|<string>'.rstrip('<string>')'|<string>'.strip('<string>')'|<string>'.capitalize()'|""''.join(reversed(""<string>'))'|<string>'.replace('<string>','<string>', 1)'|<string>'.replace('<string>','<string>')'|<string>'.replace('<char>','<char>', 1)'|<string>'.replace('<char>','<char>')'|<string>'.replace('<char>',"""")'|'setchar('<string>','<char>','<int>')'
<int_var> ::= 'i0'|'i1'|'i2'|'in0'
<int_assign> ::= <int_var>' = '<int>|<int_var>' '<arith_ops>'= '<int>
<arith_ops> ::= '+'|'-'|'*'
<int_arith_ops_protected> ::= 'divInt'|'mod'
<arith_prefix> ::= '+'|'-'
<char> ::= 'int_to_chr('<int>')'|'getCharFromString('<string>', '<int>')'
<string_var> ::= 's0'|'s1'|'s2'|'res0'
<string_slice> ::= <string>'['<int>':'<int>']'|<string>'[:'<int>']'|<string>'['<int>':]'|<string>'[1:]'|<string>'[:1]'
<string_const> ::= ""'""<string_const_part>""'""|""'small'""|""'large'""
<string_literal> ::= ''|'\\n'|'\\t'|' '|'!'|'""'|'#'|'$'|'%'|'&'|""\\'""|'('|')'|'*'|'+'|','|'-'|'.'|'/'|'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|':'|';'|'<'|'='|'>'|'?'|'@'|'A'|'B'|'C'|'D'|'E'|'F'|'G'|'H'|'I'|'J'|'K'|'L'|'M'|'N'|'O'|'P'|'Q'|'R'|'S'|'T'|'U'|'V'|'W'|'X'|'Y'|'Z'|'['|'\\\\'|']'|'^'|'_'|'`'|'a'|'b'|'c'|'d'|'e'|'f'|'g'|'h'|'i'|'j'|'k'|'l'|'m'|'n'|'o'|'p'|'q'|'r'|'s'|'t'|'u'|'v'|'w'|'x'|'y'|'z'|'{'|'|'|'}'

"
For Loop Index,"Given 3 integer inputs start, end, and step, return the integers in a list
n0 = start
ni = ni−1 + step
for each ni < end, each on the list.","Write a python function using given grammar without comment, explanation, example usage. Function parameter name has to be in0, in1...(depends on how many parameter it needs), and return variable name has to be res0, res1...(depends on how many parameter it needs).
problem description: Given 3 integer inputs start, end, and step, return the integers in a list
n0 = start
ni = ni−1 + step
for each ni < end, each on the list.
problem grammar: <predefined> ::= ""i0 = int(); i1 = int(); i2 = int()""
""b0 = bool(); b1 = bool(); b2 = bool()""
""li0 = []; li1 = []; li2 = []""
""res0 = []""
""if 'rec_counter' not in globals():{:""
""globals()['rec_counter'] = 0:}""
""global rec_counter""
<code>
<code> ::= <code><statement>'\n'|<statement>'\n'<code>|<code><statement>'\n'<code>|<statement>'\n'
<statement> ::= <simple_stmt>|<compound_stmt>
<simple_stmt> ::= <call>|<assign>
<compound_stmt> ::= <for>|<if>|'loopBreak% = 0\nwhile '<bool>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<call> ::= <list_int_var>'.append('<int>')'|<list_int_var>'.insert('<int>','<int>')'|<list_int_var>'.insert(0,'<int>')'|'deleteListItem('<list_int>', '<int>')'|'setListIndexTo('<list_int>', '<int>', '<int>')'|'if rec_counter < 900 and not stop.value:{:'
'rec_counter += 1'
<list_int_var>' = evolve('<int>', '<int>', '<int>')'
'rec_counter -= 1'
':}'|'return res0'
<assign> ::= <bool_var>' = '<bool>|<int_assign>|<list_int_var>' = '<list_int>
<for> ::= 'loopBreak% = 0\nfor forCounter% in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in '<list_int>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in '<list_int>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<number> ::= <number><num>|<num><number>|<number><num><number>|<num>
<num> ::= '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
<comp_op> ::= '<'|'>'|'=='|'>='|'<='|'!='|'is'|'is not'
<in_list_comp_op> ::= 'in'|'not in'
<list_comp_op> ::= '=='|'!='
<bool_var> ::= 'b0'|'b1'|'b2'
<bool> ::= <bool_var>|<bool_const>|'(not '<bool>')'|'('<bool>' '<bool_op>' '<bool>')'|'( not '<bool>' and '<bool>')'|'('<bool>' and not '<bool>')'|'('<int>' '<comp_op>' '<int>')'|'bool('<int>')'|'('<int>' '<in_list_comp_op>' '<list_int>')'|'('<list_int>' '<list_comp_op>' '<list_int>')'|'('<list_int>' == [])'
<bool_op> ::= 'and'|'or'|'^'|'=='
<bool_const> ::= 'True'|'False'
<if> ::= 'if '<bool>':{:\n'<code>':}'|'if '<bool>':{:\n'<code>':}else:{:\n'<code>':}'
<int> ::= 'int('<bool>')'|<int_var>|'int('<number>'.0)'|<arith_prefix><int>|'( '<int>' '<arith_ops>' '<int>' )'|<int_arith_ops_protected>'('<int>','<int>')'|'min('<int>', '<int>')'|'max('<int>', '<int>')'|'abs('<int>')'|'('<int>' + 1)'|'('<int>' - 1)'|'getIndexIntList('<list_int>', '<int>')'|'len('<list_int>')'|'getIndexIntList('<list_int>', 0)'|'getIndexIntList('<list_int>', -1)'|'saveIndex('<list_int>', '<int>')'|<list_int>'.count('<int>')'
<int_var> ::= 'i0'|'i1'|'i2'|'in0'|'in1'|'in2'
<int_assign> ::= <int_var>' = '<int>|<int_var>' '<arith_ops>'= '<int>
<arith_ops> ::= '+'|'-'|'*'
<int_arith_ops_protected> ::= 'divInt'|'mod'
<arith_prefix> ::= '+'|'-'
<list_int_var> ::= 'li0'|'li1'|'li2'|'res0'
<list_int> ::= <list_int_var>|'list(saveRange('<int>','<int>'))'|<list_int_slice>|'list(reversed('<list_int>'))'|'[x if x == '<int>' else '<int>' for x in '<list_int>']'|'replaceFirstElementInList('<list_int>','<int>','<int>')'|'[x for x in '<list_int>' if x == '<int>']'
<list_int_slice> ::= <list_int>'['<int>':'<int>']'|<list_int>'[:'<int>']'|<list_int>'['<int>':]'|<list_int>'[1:]'|<list_int>'[:1]'

"
Compare String Lengths,"Given three strings n1, n2, and n3, return true if length(n1) < length(n2) < length(n3), and false otherwise.","Write a python function using given grammar without comment, explanation, example usage. Function parameter name has to be in0, in1...(depends on how many parameter it needs), and return variable name has to be res0, res1...(depends on how many parameter it needs).
problem description: Given three strings n1, n2, and n3, return true if length(n1) < length(n2) < length(n3), and false otherwise.
problem grammar: <predefined> ::= ""i0 = int(); i1 = int(); i2 = int()""
""b0 = bool(); b1 = bool(); b2 = bool()""
""s0 = str(); s1 = str(); s2 = str()""
""res0 = bool()""
""if 'rec_counter' not in globals():{:""
""globals()['rec_counter'] = 0:}""
""global rec_counter""
<code>
<code> ::= <code><statement>'\n'|<statement>'\n'<code>|<code><statement>'\n'<code>|<statement>'\n'
<statement> ::= <simple_stmt>|<compound_stmt>
<simple_stmt> ::= <call>|<assign>
<compound_stmt> ::= <for>|<if>|'loopBreak% = 0\nwhile '<bool>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<call> ::= 'if rec_counter < 900 and not stop.value:{:'
'rec_counter += 1'
<bool_var>' = evolve('<string>', '<string>', '<string>')'
'rec_counter -= 1'
':}'|'return res0'
<assign> ::= <bool_var>' = '<bool>|<int_assign>|<string_var>' = '<string>
<for> ::= 'loopBreak% = 0\nfor forCounter% in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in '<string>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in '<string>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in '<string>'.strip().split():{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in saveSplit('<string>'.strip(), '<string>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<number> ::= <number><num>|<num><number>|<number><num><number>|<num>
<num> ::= '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
<comp_op> ::= '<'|'>'|'=='|'>='|'<='|'!='|'is'|'is not'
<string_const_part> ::= <string_const_part><string_literal>|<string_literal><string_const_part>|<string_const_part><string_literal><string_const_part>|<string_literal>
<bool_var> ::= 'b0'|'b1'|'b2'|'res0'
<bool> ::= <bool_var>|<bool_const>|'(not '<bool>')'|'('<bool>' '<bool_op>' '<bool>')'|'( not '<bool>' and '<bool>')'|'('<bool>' and not '<bool>')'|'('<int>' '<comp_op>' '<int>')'|'bool('<int>')'|'('<string>' in '<string>')'|'('<string>' not in '<string>')'|'('<string>' == '<string>')'|'('<string>' != '<string>')'|<string>'.startswith('<string>')'|<string>'.endswith('<string>')'|'(not '<string>')'
<bool_op> ::= 'and'|'or'|'^'|'=='
<bool_const> ::= 'True'|'False'
<if> ::= 'if '<bool>':{:\n'<code>':}'|'if '<bool>':{:\n'<code>':}else:{:\n'<code>':}'
<int> ::= 'int('<bool>')'|<int_var>|'int('<number>'.0)'|<arith_prefix><int>|'( '<int>' '<arith_ops>' '<int>' )'|<int_arith_ops_protected>'('<int>','<int>')'|'min('<int>', '<int>')'|'max('<int>', '<int>')'|'abs('<int>')'|'('<int>' + 1)'|'('<int>' - 1)'|'len('<string>')'|<string>'.count('<char>')'|<string>'.count('<string>')'
<string> ::= 'str('<bool>')'|'str('<int>')'|<string_var>|""'""<string_const_part>""'""|<string_slice>|'('<string>' + '<string>')'|<string>'.lstrip()'|<string>'.rstrip()'|<string>'.strip()'|<string>'.lstrip('<string>')'|<string>'.rstrip('<string>')'|<string>'.strip('<string>')'|<string>'.capitalize()'|""''.join(reversed(""<string>'))'|<string>'.replace('<string>','<string>', 1)'|<string>'.replace('<string>','<string>')'|<string>'.replace('<char>','<char>', 1)'|<string>'.replace('<char>','<char>')'|<string>'.replace('<char>',"""")'|'setchar('<string>','<char>','<int>')'
<int_var> ::= 'i0'|'i1'|'i2'
<int_assign> ::= <int_var>' = '<int>|<int_var>' '<arith_ops>'= '<int>
<arith_ops> ::= '+'|'-'|'*'
<int_arith_ops_protected> ::= 'divInt'|'mod'
<arith_prefix> ::= '+'|'-'
<char> ::= 'int_to_chr('<int>')'|'getCharFromString('<string>', '<int>')'
<string_var> ::= 's0'|'s1'|'s2'|'in0'|'in1'|'in2'
<string_slice> ::= <string>'['<int>':'<int>']'|<string>'[:'<int>']'|<string>'['<int>':]'|<string>'[1:]'|<string>'[:1]'
<string_literal> ::= ''|'\\n'|'\\t'|' '|'!'|'""'|'#'|'$'|'%'|'&'|""\\'""|'('|')'|'*'|'+'|','|'-'|'.'|'/'|'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|':'|';'|'<'|'='|'>'|'?'|'@'|'A'|'B'|'C'|'D'|'E'|'F'|'G'|'H'|'I'|'J'|'K'|'L'|'M'|'N'|'O'|'P'|'Q'|'R'|'S'|'T'|'U'|'V'|'W'|'X'|'Y'|'Z'|'['|'\\\\'|']'|'^'|'_'|'`'|'a'|'b'|'c'|'d'|'e'|'f'|'g'|'h'|'i'|'j'|'k'|'l'|'m'|'n'|'o'|'p'|'q'|'r'|'s'|'t'|'u'|'v'|'w'|'x'|'y'|'z'|'{'|'|'|'}'
"
Double Letters,"Given a string, return the string, doubling every letter character, and tripling every exclamation point. All other non-alphabetic and non-exclamation characters should be returned a single time each.","Write a python function using given grammar without comment, explanation, example usage. Function parameter name has to be in0, in1...(depends on how many parameter it needs), and return variable name has to be res0, res1...(depends on how many parameter it needs).
problem description: Given a string, return the string, doubling every letter character, and tripling every exclamation point. All other non-alphabetic and non-exclamation characters should be returned a single time each.
problem grammar: <predefined> ::= ""i0 = int(); i1 = int(); i2 = int()""
""b0 = bool(); b1 = bool(); b2 = bool()""
""s0 = str(); s1 = str(); s2 = str()""
""c0 = ' '; c1 = ' '; c2 = ' '""
""res0 = str()""
""if 'rec_counter' not in globals():{:""
""globals()['rec_counter'] = 0:}""
""global rec_counter""
<code>
<code> ::= <code><statement>'\n'|<statement>'\n'<code>|<code><statement>'\n'<code>|<statement>'\n'
<statement> ::= <simple_stmt>|<compound_stmt>
<simple_stmt> ::= <call>|<assign>
<compound_stmt> ::= <for>|<if>|'loopBreak% = 0\nwhile '<bool>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<call> ::= 'if rec_counter < 900 and not stop.value:{:'
'rec_counter += 1'
<string_var>' = evolve('<string>')'
'rec_counter -= 1'
':}'|'return res0'
<assign> ::= <bool_var>' = '<bool>|<int_assign>|<char_var>' = '<char>|<string_var>' = '<string>
<for> ::= 'loopBreak% = 0\nfor forCounter% in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in '<string>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<char_var>' in '<string>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in '<string>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in '<string>'.strip().split():{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in saveSplit('<string>'.strip(), '<string>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<number> ::= <number><num>|<num><number>|<number><num><number>|<num>
<num> ::= '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
<comp_op> ::= '<'|'>'|'=='|'>='|'<='|'!='|'is'|'is not'
<string_const_part> ::= <string_const_part><string_literal>|<string_literal><string_const_part>|<string_const_part><string_literal><string_const_part>|<string_literal>
<bool_var> ::= 'b0'|'b1'|'b2'
<bool> ::= <bool_var>|<bool_const>|'(not '<bool>')'|'('<bool>' '<bool_op>' '<bool>')'|'( not '<bool>' and '<bool>')'|'('<bool>' and not '<bool>')'|'('<int>' '<comp_op>' '<int>')'|'bool('<int>')'|<char>'.isdigit()'|<char>'.isspace()'|<char>'.isalpha()'|'('<char>' == '<char>')'|'('<string>' in '<string>')'|'('<string>' not in '<string>')'|'('<string>' == '<string>')'|'('<string>' != '<string>')'|<string>'.startswith('<string>')'|<string>'.endswith('<string>')'|'(not '<string>')'
<bool_op> ::= 'and'|'or'|'^'|'=='
<bool_const> ::= 'True'|'False'
<if> ::= 'if '<bool>':{:\n'<code>':}'|'if '<bool>':{:\n'<code>':}else:{:\n'<code>':}'
<int> ::= 'int('<bool>')'|<int_var>|'int('<number>'.0)'|<arith_prefix><int>|'( '<int>' '<arith_ops>' '<int>' )'|<int_arith_ops_protected>'('<int>','<int>')'|'min('<int>', '<int>')'|'max('<int>', '<int>')'|'abs('<int>')'|'('<int>' + 1)'|'('<int>' - 1)'|'ord('<char>')'|'len('<string>')'|<string>'.count('<char>')'|<string>'.count('<string>')'
<string> ::= 'str('<bool>')'|'str('<int>')'|<char>|<string_var>|""'""<string_const_part>""'""|<string_slice>|'('<string>' + '<string>')'|<string>'.lstrip()'|<string>'.rstrip()'|<string>'.strip()'|<string>'.lstrip('<string>')'|<string>'.rstrip('<string>')'|<string>'.strip('<string>')'|<string>'.capitalize()'|""''.join(reversed(""<string>'))'|<string>'.replace('<string>','<string>', 1)'|<string>'.replace('<string>','<string>')'|<string>'.replace('<char>','<char>', 1)'|<string>'.replace('<char>','<char>')'|<string>'.replace('<char>',"""")'|'setchar('<string>','<char>','<int>')'
<int_var> ::= 'i0'|'i1'|'i2'
<int_assign> ::= <int_var>' = '<int>|<int_var>' '<arith_ops>'= '<int>
<arith_ops> ::= '+'|'-'|'*'
<int_arith_ops_protected> ::= 'divInt'|'mod'
<arith_prefix> ::= '+'|'-'
<char> ::= 'int_to_chr('<int>')'|<char_var>|""'""<char_literal>""'""|'getCharFromString('<string>', '<int>')'
<char_var> ::= 'c0'|'c1'|'c2'
<char_literal> ::= '\\n'|'\\t'|' '|'!'|'""'|'#'|'$'|'%'|'&'|""\\'""|'('|')'|'*'|'+'|','|'-'|'.'|'/'|'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|':'|';'|'<'|'='|'>'|'?'|'@'|'A'|'B'|'C'|'D'|'E'|'F'|'G'|'H'|'I'|'J'|'K'|'L'|'M'|'N'|'O'|'P'|'Q'|'R'|'S'|'T'|'U'|'V'|'W'|'X'|'Y'|'Z'|'['|'\\\\'|']'|'^'|'_'|'`'|'a'|'b'|'c'|'d'|'e'|'f'|'g'|'h'|'i'|'j'|'k'|'l'|'m'|'n'|'o'|'p'|'q'|'r'|'s'|'t'|'u'|'v'|'w'|'x'|'y'|'z'|'{'|'|'|'}'
<string_var> ::= 's0'|'s1'|'s2'|'res0'|'in0'
<string_slice> ::= <string>'['<int>':'<int>']'|<string>'[:'<int>']'|<string>'['<int>':]'|<string>'[1:]'|<string>'[:1]'
<string_literal> ::= ''|'\\n'|'\\t'|' '|'!'|'""'|'#'|'$'|'%'|'&'|""\\'""|'('|')'|'*'|'+'|','|'-'|'.'|'/'|'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|':'|';'|'<'|'='|'>'|'?'|'@'|'A'|'B'|'C'|'D'|'E'|'F'|'G'|'H'|'I'|'J'|'K'|'L'|'M'|'N'|'O'|'P'|'Q'|'R'|'S'|'T'|'U'|'V'|'W'|'X'|'Y'|'Z'|'['|'\\\\'|']'|'^'|'_'|'`'|'a'|'b'|'c'|'d'|'e'|'f'|'g'|'h'|'i'|'j'|'k'|'l'|'m'|'n'|'o'|'p'|'q'|'r'|'s'|'t'|'u'|'v'|'w'|'x'|'y'|'z'|'{'|'|'|'}'
"
Collatz Numbers,"Given an integer, return the number of terms in the Collatz (hailstone) sequence starting from that integer.","Write a python function using given grammar without comment, explanation, example usage. Function parameter name has to be in0, in1...(depends on how many parameter it needs), and return variable name has to be res0, res1...(depends on how many parameter it needs).
problem description: Given an integer, return the number of terms in the Collatz (hailstone) sequence starting from that integer.
problem grammar: <predefined> ::= ""i0 = int(); i1 = int(); i2 = int()""
""f0 = float(); f1 = float(); f2 = float()""
""b0 = bool(); b1 = bool(); b2 = bool()""
""res0 = int()""
""if 'rec_counter' not in globals():{:""
""globals()['rec_counter'] = 0:}""
""global rec_counter""
<code>
<code> ::= <code><statement>'\n'|<statement>'\n'<code>|<code><statement>'\n'<code>|<statement>'\n'
<statement> ::= <simple_stmt>|<compound_stmt>
<simple_stmt> ::= <call>|<assign>
<compound_stmt> ::= <for>|<if>|'loopBreak% = 0\nwhile '<bool>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<call> ::= 'if rec_counter < 900 and not stop.value:{:'
'rec_counter += 1'
<int_var>' = evolve('<int>')'
'rec_counter -= 1'
':}'|'return res0'
<assign> ::= <bool_var>' = '<bool>|<int_assign>|<float_assign>
<for> ::= 'loopBreak% = 0\nfor forCounter% in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<number> ::= <number><num>|<num><number>|<number><num><number>|<num>
<num> ::= '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
<comp_op> ::= '<'|'>'|'=='|'>='|'<='|'!='|'is'|'is not'
<bool_var> ::= 'b0'|'b1'|'b2'
<bool> ::= <bool_var>|<bool_const>|'(not '<bool>')'|'('<bool>' '<bool_op>' '<bool>')'|'( not '<bool>' and '<bool>')'|'('<bool>' and not '<bool>')'|'('<int>' '<comp_op>' '<int>')'|'bool('<int>')'|'('<float>' '<comp_op>' '<float>')'|'bool('<float>')'
<bool_op> ::= 'and'|'or'|'^'|'=='
<bool_const> ::= 'True'|'False'
<if> ::= 'if '<bool>':{:\n'<code>':}'|'if '<bool>':{:\n'<code>':}else:{:\n'<code>':}'
<int> ::= 'int('<bool>')'|<int_var>|'int('<number>'.0)'|<arith_prefix><int>|'( '<int>' '<arith_ops>' '<int>' )'|<int_arith_ops_protected>'('<int>','<int>')'|'min('<int>', '<int>')'|'max('<int>', '<int>')'|'abs('<int>')'|'('<int>' + 1)'|'('<int>' - 1)'|'int(math.ceil('<float>'))'|'int(math.floor('<float>'))'|'int(round('<float>'))'|'int('<float>')'
<float> ::= 'float('<bool>')'|<int>|<float_var>|<number>'.'<number>|<arith_prefix><float>|'('<float>' '<arith_ops>' '<float>')'|<float_arith_ops_protected>'('<float>','<float>')'|'math.ceil('<float>')'|'math.floor('<float>')'|'round('<float>')'|'min('<float>', '<float>')'|'max('<float>', '<float>')'|'abs('<float>')'|'math.sin('<float>')'|'math.cos('<float>')'|'math.tan('<float>')'|'('<float>' + 1)'|'('<float>' - 1)'
<int_var> ::= 'i0'|'i1'|'i2'|'res0'|'in0'
<int_assign> ::= <int_var>' = '<int>|<int_var>' '<arith_ops>'= '<int>
<arith_ops> ::= '+'|'-'|'*'
<int_arith_ops_protected> ::= 'divInt'|'mod'
<arith_prefix> ::= '+'|'-'
<float_var> ::= 'f0'|'f1'|'f2'
<float_assign> ::= <float_var>' = '<float>|<float_var>' '<arith_ops>'= '<float>
<float_arith_ops_protected> ::= 'div'|'divInt'|'mod'
"
Replace Space with Newline,"Given a string input, return the string, replacing spaces with newlines. Also, return the integer count of the nonwhitespace characters. The input string will not have tabs or newlines.","Write a python function using given grammar without comment, explanation, example usage. Function parameter name has to be in0, in1...(depends on how many parameter it needs), and return variable name has to be res0, res1...(depends on how many parameter it needs).
problem description: Given a string input, return the string, replacing spaces with newlines. Also, return the integer count of the nonwhitespace characters. The input string will not have tabs or newlines.
problem grammar: <predefined> ::= ""i0 = int(); i1 = int(); i2 = int()""
""b0 = bool(); b1 = bool(); b2 = bool()""
""s0 = str(); s1 = str(); s2 = str()""
""c0 = ' '; c1 = ' '; c2 = ' '""
""res0 = str(); res1 = int()""
""if 'rec_counter' not in globals():{:""
""globals()['rec_counter'] = 0:}""
""global rec_counter""
<code>
<code> ::= <code><statement>'\n'|<statement>'\n'<code>|<code><statement>'\n'<code>|<statement>'\n'
<statement> ::= <simple_stmt>|<compound_stmt>
<simple_stmt> ::= <call>|<assign>
<compound_stmt> ::= <for>|<if>|'loopBreak% = 0\nwhile '<bool>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<call> ::= 'if rec_counter < 900 and not stop.value:{:'
'rec_counter += 1'
<string_var>', '<int_var>' = evolve('<string>')'
'rec_counter -= 1'
':}'|'return res0, res1'
<assign> ::= <bool_var>' = '<bool>|<int_assign>|<char_var>' = '<char>|<string_var>' = '<string>
<for> ::= 'loopBreak% = 0\nfor forCounter% in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in '<string>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<char_var>' in '<string>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in '<string>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in '<string>'.strip().split():{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in saveSplit('<string>'.strip(), '<string>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<number> ::= <number><num>|<num><number>|<number><num><number>|<num>
<num> ::= '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
<comp_op> ::= '<'|'>'|'=='|'>='|'<='|'!='|'is'|'is not'
<string_const_part> ::= <string_const_part><string_literal>|<string_literal><string_const_part>|<string_const_part><string_literal><string_const_part>|<string_literal>
<bool_var> ::= 'b0'|'b1'|'b2'
<bool> ::= <bool_var>|<bool_const>|'(not '<bool>')'|'('<bool>' '<bool_op>' '<bool>')'|'( not '<bool>' and '<bool>')'|'('<bool>' and not '<bool>')'|'('<int>' '<comp_op>' '<int>')'|'bool('<int>')'|<char>'.isdigit()'|<char>'.isspace()'|<char>'.isalpha()'|'('<char>' == '<char>')'|'('<string>' in '<string>')'|'('<string>' not in '<string>')'|'('<string>' == '<string>')'|'('<string>' != '<string>')'|<string>'.startswith('<string>')'|<string>'.endswith('<string>')'|'(not '<string>')'
<bool_op> ::= 'and'|'or'|'^'|'=='
<bool_const> ::= 'True'|'False'
<if> ::= 'if '<bool>':{:\n'<code>':}'|'if '<bool>':{:\n'<code>':}else:{:\n'<code>':}'
<int> ::= 'int('<bool>')'|<int_var>|'int('<number>'.0)'|<arith_prefix><int>|'( '<int>' '<arith_ops>' '<int>' )'|<int_arith_ops_protected>'('<int>','<int>')'|'min('<int>', '<int>')'|'max('<int>', '<int>')'|'abs('<int>')'|'('<int>' + 1)'|'('<int>' - 1)'|'ord('<char>')'|'len('<string>')'|<string>'.count('<char>')'|<string>'.count('<string>')'
<string> ::= 'str('<bool>')'|'str('<int>')'|<char>|<string_var>|""'""<string_const_part>""'""|<string_slice>|'('<string>' + '<string>')'|<string>'.lstrip()'|<string>'.rstrip()'|<string>'.strip()'|<string>'.lstrip('<string>')'|<string>'.rstrip('<string>')'|<string>'.strip('<string>')'|<string>'.capitalize()'|""''.join(reversed(""<string>'))'|<string>'.replace('<string>','<string>', 1)'|<string>'.replace('<string>','<string>')'|<string>'.replace('<char>','<char>', 1)'|<string>'.replace('<char>','<char>')'|<string>'.replace('<char>',"""")'|'setchar('<string>','<char>','<int>')'
<int_var> ::= 'i0'|'i1'|'i2'|'res1'
<int_assign> ::= <int_var>' = '<int>|<int_var>' '<arith_ops>'= '<int>
<arith_ops> ::= '+'|'-'|'*'
<int_arith_ops_protected> ::= 'divInt'|'mod'
<arith_prefix> ::= '+'|'-'
<char> ::= 'int_to_chr('<int>')'|<char_var>|""'""<char_literal>""'""|'getCharFromString('<string>', '<int>')'
<char_var> ::= 'c0'|'c1'|'c2'
<char_literal> ::= '\\n'|'\\t'|' '|'!'|'""'|'#'|'$'|'%'|'&'|""\\'""|'('|')'|'*'|'+'|','|'-'|'.'|'/'|'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|':'|';'|'<'|'='|'>'|'?'|'@'|'A'|'B'|'C'|'D'|'E'|'F'|'G'|'H'|'I'|'J'|'K'|'L'|'M'|'N'|'O'|'P'|'Q'|'R'|'S'|'T'|'U'|'V'|'W'|'X'|'Y'|'Z'|'['|'\\\\'|']'|'^'|'_'|'`'|'a'|'b'|'c'|'d'|'e'|'f'|'g'|'h'|'i'|'j'|'k'|'l'|'m'|'n'|'o'|'p'|'q'|'r'|'s'|'t'|'u'|'v'|'w'|'x'|'y'|'z'|'{'|'|'|'}'
<string_var> ::= 's0'|'s1'|'s2'|'res0'|'in0'
<string_slice> ::= <string>'['<int>':'<int>']'|<string>'[:'<int>']'|<string>'['<int>':]'|<string>'[1:]'|<string>'[:1]'
<string_literal> ::= ''|'\\n'|'\\t'|' '|'!'|'""'|'#'|'$'|'%'|'&'|""\\'""|'('|')'|'*'|'+'|','|'-'|'.'|'/'|'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|':'|';'|'<'|'='|'>'|'?'|'@'|'A'|'B'|'C'|'D'|'E'|'F'|'G'|'H'|'I'|'J'|'K'|'L'|'M'|'N'|'O'|'P'|'Q'|'R'|'S'|'T'|'U'|'V'|'W'|'X'|'Y'|'Z'|'['|'\\\\'|']'|'^'|'_'|'`'|'a'|'b'|'c'|'d'|'e'|'f'|'g'|'h'|'i'|'j'|'k'|'l'|'m'|'n'|'o'|'p'|'q'|'r'|'s'|'t'|'u'|'v'|'w'|'x'|'y'|'z'|'{'|'|'|'}'

"
Even Squares,"Given an integer n, return all of the positive even perfect squares less than n on a list.","Write a python function using given grammar without comment, explanation, example usage. Function parameter name has to be in0, in1...(depends on how many parameter it needs), and return variable name has to be res0, res1...(depends on how many parameter it needs).
problem description: Given an integer n, return all of the positive even perfect squares less than n on a list.
problem grammar: <predefined> ::= ""i0 = int(); i1 = int(); i2 = int()""
""b0 = bool(); b1 = bool(); b2 = bool()""
""li0 = []; li1 = []; li2 = []""
""res0 = []""
""if 'rec_counter' not in globals():{:""
""globals()['rec_counter'] = 0:}""
""global rec_counter""
<code>
<code> ::= <code><statement>'\n'|<statement>'\n'<code>|<code><statement>'\n'<code>|<statement>'\n'
<statement> ::= <simple_stmt>|<compound_stmt>
<simple_stmt> ::= <call>|<assign>
<compound_stmt> ::= <for>|<if>|'loopBreak% = 0\nwhile '<bool>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<call> ::= <list_int_var>'.append('<int>')'|<list_int_var>'.insert('<int>','<int>')'|<list_int_var>'.insert(0,'<int>')'|'deleteListItem('<list_int>', '<int>')'|'setListIndexTo('<list_int>', '<int>', '<int>')'|'if rec_counter < 900 and not stop.value:{:'
'rec_counter += 1'
<list_int_var>' = evolve('<int>')'
'rec_counter -= 1'
':}'|'return res0'
<assign> ::= <bool_var>' = '<bool>|<int_assign>|<list_int_var>' = '<list_int>
<for> ::= 'loopBreak% = 0\nfor forCounter% in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in '<list_int>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in '<list_int>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<number> ::= <number><num>|<num><number>|<number><num><number>|<num>
<num> ::= '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
<comp_op> ::= '<'|'>'|'=='|'>='|'<='|'!='|'is'|'is not'
<in_list_comp_op> ::= 'in'|'not in'
<list_comp_op> ::= '=='|'!='
<bool_var> ::= 'b0'|'b1'|'b2'
<bool> ::= <bool_var>|<bool_const>|'(not '<bool>')'|'('<bool>' '<bool_op>' '<bool>')'|'( not '<bool>' and '<bool>')'|'('<bool>' and not '<bool>')'|'('<int>' '<comp_op>' '<int>')'|'bool('<int>')'|'('<int>' '<in_list_comp_op>' '<list_int>')'|'('<list_int>' '<list_comp_op>' '<list_int>')'|'('<list_int>' == [])'
<bool_op> ::= 'and'|'or'|'^'|'=='
<bool_const> ::= 'True'|'False'
<if> ::= 'if '<bool>':{:\n'<code>':}'|'if '<bool>':{:\n'<code>':}else:{:\n'<code>':}'
<int> ::= 'int('<bool>')'|<int_var>|'int('<number>'.0)'|<arith_prefix><int>|'( '<int>' '<arith_ops>' '<int>' )'|<int_arith_ops_protected>'('<int>','<int>')'|'min('<int>', '<int>')'|'max('<int>', '<int>')'|'abs('<int>')'|'('<int>' + 1)'|'('<int>' - 1)'|'getIndexIntList('<list_int>', '<int>')'|'len('<list_int>')'|'getIndexIntList('<list_int>', 0)'|'getIndexIntList('<list_int>', -1)'|'saveIndex('<list_int>', '<int>')'|<list_int>'.count('<int>')'
<int_var> ::= 'i0'|'i1'|'i2'|'in0'
<int_assign> ::= <int_var>' = '<int>|<int_var>' '<arith_ops>'= '<int>
<arith_ops> ::= '+'|'-'|'*'
<int_arith_ops_protected> ::= 'divInt'|'mod'
<arith_prefix> ::= '+'|'-'
<list_int_var> ::= 'li0'|'li1'|'li2'|'res0'
<list_int> ::= <list_int_var>|'list(saveRange('<int>','<int>'))'|<list_int_slice>|'list(reversed('<list_int>'))'|'[x if x == '<int>' else '<int>' for x in '<list_int>']'|'replaceFirstElementInList('<list_int>','<int>','<int>')'|'[x for x in '<list_int>' if x == '<int>']'
<list_int_slice> ::= <list_int>'['<int>':'<int>']'|<list_int>'[:'<int>']'|<list_int>'['<int>':]'|<list_int>'[1:]'|<list_int>'[:1]'
"
Wallis Pi,"John Wallis gave the following infinite product that converges to π/4:
(2/3) * (4/3) * (4/5) * (6/5) * (6/7) * (8/7) * (8/9) * (10/9) * ... 
Given an integer input n, compute an approximation of this product out to n terms. Results are rounded to 5 decimal places.","Write a python function using given grammar without comment, explanation, example usage. Function parameter name has to be in0, in1...(depends on how many parameter it needs), and return variable name has to be res0, res1...(depends on how many parameter it needs).
problem description: John Wallis gave the following infinite product that converges to π/4:
(2/3) * (4/3) * (4/5) * (6/5) * (6/7) * (8/7) * (8/9) * (10/9) * ... 
Given an integer input n, compute an approximation of this product out to n terms. Results are rounded to 5 decimal places.
problem grammar: <predefined> ::= ""i0 = int(); i1 = int(); i2 = int()""
""b0 = bool(); b1 = bool(); b2 = bool()""
""f0 = float(); f1 = float(); f2 = float()""
""res0 = float()""
""if 'rec_counter' not in globals():{:""
""globals()['rec_counter'] = 0:}""
""global rec_counter""
<code>
<code> ::= <code><statement>'\n'|<statement>'\n'<code>|<code><statement>'\n'<code>|<statement>'\n'
<statement> ::= <simple_stmt>|<compound_stmt>
<simple_stmt> ::= <call>|<assign>
<compound_stmt> ::= <for>|<if>|'loopBreak% = 0\nwhile '<bool>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<call> ::= 'if rec_counter < 900 and not stop.value:{:'
'rec_counter += 1'
<float_var>' = evolve('<int>')'
'rec_counter -= 1'
':}'|'return res0'
<assign> ::= <bool_var>' = '<bool>|<int_assign>|<float_assign>
<for> ::= 'loopBreak% = 0\nfor forCounter% in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<number> ::= <number><num>|<num><number>|<number><num><number>|<num>
<num> ::= '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
<comp_op> ::= '<'|'>'|'=='|'>='|'<='|'!='|'is'|'is not'
<bool_var> ::= 'b0'|'b1'|'b2'
<bool> ::= <bool_var>|<bool_const>|'(not '<bool>')'|'('<bool>' '<bool_op>' '<bool>')'|'( not '<bool>' and '<bool>')'|'('<bool>' and not '<bool>')'|'('<int>' '<comp_op>' '<int>')'|'bool('<int>')'|'('<float>' '<comp_op>' '<float>')'|'bool('<float>')'
<bool_op> ::= 'and'|'or'|'^'|'=='
<bool_const> ::= 'True'|'False'
<if> ::= 'if '<bool>':{:\n'<code>':}'|'if '<bool>':{:\n'<code>':}else:{:\n'<code>':}'
<int> ::= 'int('<bool>')'|<int_var>|'int('<number>'.0)'|<arith_prefix><int>|'( '<int>' '<arith_ops>' '<int>' )'|<int_arith_ops_protected>'('<int>','<int>')'|'min('<int>', '<int>')'|'max('<int>', '<int>')'|'abs('<int>')'|'('<int>' + 1)'|'('<int>' - 1)'|'int(math.ceil('<float>'))'|'int(math.floor('<float>'))'|'int(round('<float>'))'|'int('<float>')'
<float> ::= 'float('<bool>')'|<int>|<float_var>|<number>'.'<number>|<arith_prefix><float>|'('<float>' '<arith_ops>' '<float>')'|<float_arith_ops_protected>'('<float>','<float>')'|'math.ceil('<float>')'|'math.floor('<float>')'|'round('<float>')'|'min('<float>', '<float>')'|'max('<float>', '<float>')'|'abs('<float>')'|'math.sin('<float>')'|'math.cos('<float>')'|'math.tan('<float>')'|'('<float>' + 1)'|'('<float>' - 1)'
<int_var> ::= 'i0'|'i1'|'i2'|'in0'
<int_assign> ::= <int_var>' = '<int>|<int_var>' '<arith_ops>'= '<int>
<arith_ops> ::= '+'|'-'|'*'
<int_arith_ops_protected> ::= 'divInt'|'mod'
<arith_prefix> ::= '+'|'-'
<float_var> ::= 'f0'|'f1'|'f2'|'res0'
<float_assign> ::= <float_var>' = '<float>|<float_var>' '<arith_ops>'= '<float>
<float_arith_ops_protected> ::= 'div'|'divInt'|'mod'
"
String Lengths Backwards,"Given a vector of strings, return the length of each string in the vector starting with the last and ending with the first.","Write a python function using given grammar without comment, explanation, example usage. Function parameter name has to be in0, in1...(depends on how many parameter it needs), and return variable name has to be res0, res1...(depends on how many parameter it needs).
problem description: Given a vector of strings, return the length of each string in the vector starting with the last and ending with the first.
problem grammar: <predefined> ::= ""i0 = int(); i1 = int(); i2 = int()""
""b0 = bool(); b1 = bool(); b2 = bool()""
""s0 = str(); s1 = str(); s2 = str()""
""ls0 = []; ls1 = []; ls2 = []""
""li0 = []; li1 = []; li2 = []""
""res0 = []""
""if 'rec_counter' not in globals():{:""
""globals()['rec_counter'] = 0:}""
""global rec_counter""
<code>
<code> ::= <code><statement>'\n'|<statement>'\n'<code>|<code><statement>'\n'<code>|<statement>'\n'
<statement> ::= <simple_stmt>|<compound_stmt>
<simple_stmt> ::= <call>|<assign>
<compound_stmt> ::= <for>|<if>|'loopBreak% = 0\nwhile '<bool>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<call> ::= <list_int_var>'.append('<int>')'|<list_int_var>'.insert('<int>','<int>')'|<list_int_var>'.insert(0,'<int>')'|'deleteListItem('<list_int>', '<int>')'|'setListIndexTo('<list_int>', '<int>', '<int>')'|<list_string_var>'.insert('<int>','<string>')'|'deleteListItem('<list_string>', '<int>')'|'setListIndexTo('<list_string>', '<int>', '<string>')'|<list_string_var>'.append('<string>')'|<list_string_var>'.insert('<int>','<string>')'|<list_string_var>'.insert(0,'<string>')'|'deleteListItem('<list_string>', '<int>')'|'setListIndexTo('<list_string>', '<int>', '<string>')'|'if rec_counter < 900 and not stop.value:{:'
'rec_counter += 1'
<list_int_var>' = evolve('<list_string>')'
'rec_counter -= 1'
':}'|'return res0'
<assign> ::= <bool_var>' = '<bool>|<int_assign>|<string_var>' = '<string>|<list_int_var>' = '<list_int>|<list_string_var>' = '<list_string>
<for> ::= 'loopBreak% = 0\nfor forCounter% in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in '<string>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in '<string>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in '<string>'.strip().split():{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in saveSplit('<string>'.strip(), '<string>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in '<list_int>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in '<list_int>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in '<list_string>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in '<list_string>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<number> ::= <number><num>|<num><number>|<number><num><number>|<num>
<num> ::= '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
<comp_op> ::= '<'|'>'|'=='|'>='|'<='|'!='|'is'|'is not'
<string_const_part> ::= <string_const_part><string_literal>|<string_literal><string_const_part>|<string_const_part><string_literal><string_const_part>|<string_literal>
<in_list_comp_op> ::= 'in'|'not in'
<list_comp_op> ::= '=='|'!='
<bool_var> ::= 'b0'|'b1'|'b2'
<bool> ::= <bool_var>|<bool_const>|'(not '<bool>')'|'('<bool>' '<bool_op>' '<bool>')'|'( not '<bool>' and '<bool>')'|'('<bool>' and not '<bool>')'|'('<int>' '<comp_op>' '<int>')'|'bool('<int>')'|'('<string>' in '<string>')'|'('<string>' not in '<string>')'|'('<string>' == '<string>')'|'('<string>' != '<string>')'|<string>'.startswith('<string>')'|<string>'.endswith('<string>')'|'(not '<string>')'|'('<int>' '<in_list_comp_op>' '<list_int>')'|'('<list_int>' '<list_comp_op>' '<list_int>')'|'('<list_int>' == [])'|'('<string>' '<in_list_comp_op>' '<list_string>')'|'('<list_string>' '<list_comp_op>' '<list_string>')'|'('<list_string>' == [])'
<bool_op> ::= 'and'|'or'|'^'|'=='
<bool_const> ::= 'True'|'False'
<if> ::= 'if '<bool>':{:\n'<code>':}'|'if '<bool>':{:\n'<code>':}else:{:\n'<code>':}'
<int> ::= 'int('<bool>')'|<int_var>|'int('<number>'.0)'|<arith_prefix><int>|'( '<int>' '<arith_ops>' '<int>' )'|<int_arith_ops_protected>'('<int>','<int>')'|'min('<int>', '<int>')'|'max('<int>', '<int>')'|'abs('<int>')'|'('<int>' + 1)'|'('<int>' - 1)'|'len('<string>')'|<string>'.count('<char>')'|<string>'.count('<string>')'|'getIndexIntList('<list_int>', '<int>')'|'len('<list_int>')'|'getIndexIntList('<list_int>', 0)'|'getIndexIntList('<list_int>', -1)'|'saveIndex('<list_int>', '<int>')'|<list_int>'.count('<int>')'|'len('<list_string>')'|'saveIndex('<list_string>', '<string>')'|<list_string>'.count('<string>')'
<string> ::= 'str('<bool>')'|'str('<int>')'|<string_var>|""'""<string_const_part>""'""|<string_slice>|'('<string>' + '<string>')'|<string>'.lstrip()'|<string>'.rstrip()'|<string>'.strip()'|<string>'.lstrip('<string>')'|<string>'.rstrip('<string>')'|<string>'.strip('<string>')'|<string>'.capitalize()'|""''.join(reversed(""<string>'))'|<string>'.replace('<string>','<string>', 1)'|<string>'.replace('<string>','<string>')'|<string>'.replace('<char>','<char>', 1)'|<string>'.replace('<char>','<char>')'|<string>'.replace('<char>',"""")'|'setchar('<string>','<char>','<int>')'|<string>'.join('<list_string>')'|'getIndexStringList('<list_string>', '<int>')'|'getIndexStringList('<list_string>', 0)'|'getIndexStringList('<list_string>', -1)'
<int_var> ::= 'i0'|'i1'|'i2'
<int_assign> ::= <int_var>' = '<int>|<int_var>' '<arith_ops>'= '<int>
<arith_ops> ::= '+'|'-'|'*'
<int_arith_ops_protected> ::= 'divInt'|'mod'
<arith_prefix> ::= '+'|'-'
<char> ::= 'int_to_chr('<int>')'|'getCharFromString('<string>', '<int>')'
<string_var> ::= 's0'|'s1'|'s2'
<string_slice> ::= <string>'['<int>':'<int>']'|<string>'[:'<int>']'|<string>'['<int>':]'|<string>'[1:]'|<string>'[:1]'
<string_literal> ::= ''|'\\n'|'\\t'|' '|'!'|'""'|'#'|'$'|'%'|'&'|""\\'""|'('|')'|'*'|'+'|','|'-'|'.'|'/'|'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|':'|';'|'<'|'='|'>'|'?'|'@'|'A'|'B'|'C'|'D'|'E'|'F'|'G'|'H'|'I'|'J'|'K'|'L'|'M'|'N'|'O'|'P'|'Q'|'R'|'S'|'T'|'U'|'V'|'W'|'X'|'Y'|'Z'|'['|'\\\\'|']'|'^'|'_'|'`'|'a'|'b'|'c'|'d'|'e'|'f'|'g'|'h'|'i'|'j'|'k'|'l'|'m'|'n'|'o'|'p'|'q'|'r'|'s'|'t'|'u'|'v'|'w'|'x'|'y'|'z'|'{'|'|'|'}'
<list_string> ::= <string>'.strip().split()'|'saveSplit('<string>'.strip(), '<string>')'|<list_string_var>|<list_string_slice>|'saveSplit('<string>','<string>')'|'list(reversed('<list_string>'))'|'[x if x == '<string>' else '<string>' for x in '<list_string>']'|'replaceFirstElementInList('<list_string>','<string>','<string>')'|'[x for x in '<list_string>' if x == '<string>']'
<list_int_var> ::= 'li0'|'li1'|'li2'|'res0'
<list_int> ::= <list_int_var>|'list(saveRange('<int>','<int>'))'|<list_int_slice>|'list(reversed('<list_int>'))'|'[x if x == '<int>' else '<int>' for x in '<list_int>']'|'replaceFirstElementInList('<list_int>','<int>','<int>')'|'[x for x in '<list_int>' if x == '<int>']'
<list_int_slice> ::= <list_int>'['<int>':'<int>']'|<list_int>'[:'<int>']'|<list_int>'['<int>':]'|<list_int>'[1:]'|<list_int>'[:1]'
<list_string_var> ::= 'ls0'|'ls1'|'ls2'|'in0'
<list_string_slice> ::= <list_string>'['<int>':'<int>']'|<list_string>'[:'<int>']'|<list_string>'['<int>':]'|<list_string>'[1:]'|<list_string>'[:1]'
"
Last Index of Zero,"Given a vector of integers, at least one of which is 0, return the index of the last occurrence of 0 in the vector.","Write a python function using given grammar without comment, explanation, example usage. Function parameter name has to be in0, in1...(depends on how many parameter it needs), and return variable name has to be res0, res1...(depends on how many parameter it needs).
problem description: Given a vector of integers, at least one of which is 0, return the index of the last occurrence of 0 in the vector.
problem grammar: <predefined> ::= ""i0 = int(); i1 = int(); i2 = int()""
""b0 = bool(); b1 = bool(); b2 = bool()""
""li0 = []; li1 = []; li2 = []""
""res0 = int()""
""if 'rec_counter' not in globals():{:""
""globals()['rec_counter'] = 0:}""
""global rec_counter""
<code>
<code> ::= <code><statement>'\n'|<statement>'\n'<code>|<code><statement>'\n'<code>|<statement>'\n'
<statement> ::= <simple_stmt>|<compound_stmt>
<simple_stmt> ::= <call>|<assign>
<compound_stmt> ::= <for>|<if>|'loopBreak% = 0\nwhile '<bool>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<call> ::= <list_int_var>'.append('<int>')'|<list_int_var>'.insert('<int>','<int>')'|<list_int_var>'.insert(0,'<int>')'|'deleteListItem('<list_int>', '<int>')'|'setListIndexTo('<list_int>', '<int>', '<int>')'|'if rec_counter < 900 and not stop.value:{:'
'rec_counter += 1'
<int_var>' = evolve('<list_int>')'
'rec_counter -= 1'
':}'|'return res0'
<assign> ::= <bool_var>' = '<bool>|<int_assign>|<list_int_var>' = '<list_int>
<for> ::= 'loopBreak% = 0\nfor forCounter% in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in '<list_int>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in '<list_int>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<number> ::= <number><num>|<num><number>|<number><num><number>|<num>
<num> ::= '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
<comp_op> ::= '<'|'>'|'=='|'>='|'<='|'!='|'is'|'is not'
<in_list_comp_op> ::= 'in'|'not in'
<list_comp_op> ::= '=='|'!='
<bool_var> ::= 'b0'|'b1'|'b2'
<bool> ::= <bool_var>|<bool_const>|'(not '<bool>')'|'('<bool>' '<bool_op>' '<bool>')'|'( not '<bool>' and '<bool>')'|'('<bool>' and not '<bool>')'|'('<int>' '<comp_op>' '<int>')'|'bool('<int>')'|'('<int>' '<in_list_comp_op>' '<list_int>')'|'('<list_int>' '<list_comp_op>' '<list_int>')'|'('<list_int>' == [])'
<bool_op> ::= 'and'|'or'|'^'|'=='
<bool_const> ::= 'True'|'False'
<if> ::= 'if '<bool>':{:\n'<code>':}'|'if '<bool>':{:\n'<code>':}else:{:\n'<code>':}'
<int> ::= 'int('<bool>')'|<int_var>|'int('<number>'.0)'|<arith_prefix><int>|'( '<int>' '<arith_ops>' '<int>' )'|<int_arith_ops_protected>'('<int>','<int>')'|'min('<int>', '<int>')'|'max('<int>', '<int>')'|'abs('<int>')'|'('<int>' + 1)'|'('<int>' - 1)'|'getIndexIntList('<list_int>', '<int>')'|'len('<list_int>')'|'getIndexIntList('<list_int>', 0)'|'getIndexIntList('<list_int>', -1)'|'saveIndex('<list_int>', '<int>')'|<list_int>'.count('<int>')'
<int_var> ::= 'i0'|'i1'|'i2'|'res0'
<int_assign> ::= <int_var>' = '<int>|<int_var>' '<arith_ops>'= '<int>
<arith_ops> ::= '+'|'-'|'*'
<int_arith_ops_protected> ::= 'divInt'|'mod'
<arith_prefix> ::= '+'|'-'
<list_int_var> ::= 'li0'|'li1'|'li2'|'in0'
<list_int> ::= <list_int_var>|'list(saveRange('<int>','<int>'))'|<list_int_slice>|'list(reversed('<list_int>'))'|'[x if x == '<int>' else '<int>' for x in '<list_int>']'|'replaceFirstElementInList('<list_int>','<int>','<int>')'|'[x for x in '<list_int>' if x == '<int>']'
<list_int_slice> ::= <list_int>'['<int>':'<int>']'|<list_int>'[:'<int>']'|<list_int>'['<int>':]'|<list_int>'[1:]'|<list_int>'[:1]'
"
Vector Average,"Given a vector of floats, return the average of those floats. Results are rounded to 4 decimal places.","Write a python function using given grammar without comment, explanation, example usage. Function parameter name has to be in0, in1...(depends on how many parameter it needs), and return variable name has to be res0, res1...(depends on how many parameter it needs).
problem description: Given a vector of floats, return the average of those floats. Results are rounded to 4 decimal places.
problem grammar: <predefined> ::= ""i0 = int(); i1 = int(); i2 = int()""
""f0 = float(); f1 = float(); f2 = float()""
""lf0 = []; lf1 = []; lf2 = []""
""res0 = float()""
""if 'rec_counter' not in globals():{:""
""globals()['rec_counter'] = 0:}""
""global rec_counter""
<code>
<code> ::= <code><statement>'\n'|<statement>'\n'<code>|<code><statement>'\n'<code>|<statement>'\n'
<statement> ::= <simple_stmt>|<for>|'if not in0:{:
<code>:}else:{:
<code>:}'
<simple_stmt> ::= <call>|<assign>
<call> ::= <list_float_var>'.append('<float>')'|<list_float_var>'.insert('<int>','<float>')'|<list_float_var>'.insert(0,'<float>')'|'deleteListItem('<list_float>', '<int>')'|'setListIndexTo('<list_float>', '<int>', '<float>')'|'if rec_counter < 900 and not stop.value:{:'
'rec_counter += 1'
<float_var>' = evolve('<list_float>')'
'rec_counter -= 1'
':}'|'return res0'
<assign> ::= <int_assign>|<float_assign>|<list_float_var>' = '<list_float>
<for> ::= 'loopBreak% = 0\nfor forCounter% in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in '<list_float>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<float_var>' in '<list_float>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<number> ::= <number><num>|<num><number>|<number><num><number>|<num>
<num> ::= '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
<int_var> ::= 'i0'|'i1'|'i2'
<int_assign> ::= <int_var>' = '<int>|<int_var>' '<arith_ops>'= '<int>
<int> ::= <int_var>|'int('<number>'.0)'|<arith_prefix><int>|'( '<int>' '<arith_ops>' '<int>' )'|<int_arith_ops_protected>'('<int>','<int>')'|'min('<int>', '<int>')'|'max('<int>', '<int>')'|'abs('<int>')'|'('<int>' + 1)'|'('<int>' - 1)'|'int(math.ceil('<float>'))'|'int(math.floor('<float>'))'|'int(round('<float>'))'|'int('<float>')'|'len('<list_float>')'|'saveIndex('<list_float>', '<float>')'|<list_float>'.count('<float>')'
<arith_ops> ::= '+'|'-'|'*'
<int_arith_ops_protected> ::= 'divInt'|'mod'
<arith_prefix> ::= '+'|'-'
<float> ::= <int>|<float_var>|<number>'.'<number>|<arith_prefix><float>|'('<float>' '<arith_ops>' '<float>')'|<float_arith_ops_protected>'('<float>','<float>')'|'math.ceil('<float>')'|'math.floor('<float>')'|'round('<float>')'|'min('<float>', '<float>')'|'max('<float>', '<float>')'|'abs('<float>')'|'math.sin('<float>')'|'math.cos('<float>')'|'math.tan('<float>')'|'('<float>' + 1)'|'('<float>' - 1)'|'getIndexFloatList('<list_float>', '<int>')'|'getIndexFloatList('<list_float>', 0)'|'getIndexFloatList('<list_float>', -1)'|'sum('<list_float>')'
<float_var> ::= 'f0'|'f1'|'f2'|'res0'
<float_assign> ::= <float_var>' = '<float>|<float_var>' '<arith_ops>'= '<float>
<float_arith_ops_protected> ::= 'div'|'divInt'|'mod'
<list_float_var> ::= 'lf0'|'lf1'|'lf2'|'in0'
<list_float> ::= <list_float_var>|<list_float_slice>|'list(reversed('<list_float>'))'|'[x if x == '<float>' else '<float>' for x in '<list_float>']'|'replaceFirstElementInList('<list_float>','<float>','<float>')'|'[x for x in '<list_float>' if x == '<float>']'
<list_float_slice> ::= <list_float>'['<int>':'<int>']'|<list_float>'[:'<int>']'|<list_float>'['<int>':]'|<list_float>'[1:]'|<list_float>'[:1]'
"
Count Odds,"Given a vector of integers, return the number of integers that are odd, without use of a specific even or odd instruction (but allowing instructions such as mod and quotient).","Write a python function using given grammar without comment, explanation, example usage. Function parameter name has to be in0, in1...(depends on how many parameter it needs), and return variable name has to be res0, res1...(depends on how many parameter it needs).
problem description: Given a vector of integers, return the number of integers that are odd, without use of a specific even or odd instruction (but allowing instructions such as mod and quotient).
problem grammar: <predefined> ::= ""b0 = bool(); b1 = bool(); b2 = bool()""
""i0 = int(); i1 = int(); i2 = int()""
""li0 = []; li1 = []; li2 = []""
""res0 = int()""
""if 'rec_counter' not in globals():{:""
""globals()['rec_counter'] = 0:}""
""global rec_counter""
<code>
<code> ::= <code><statement>'\n'|<statement>'\n'<code>|<code><statement>'\n'<code>|<statement>'\n'
<statement> ::= <simple_stmt>|<compound_stmt>
<simple_stmt> ::= <call>|<assign>
<compound_stmt> ::= <for>|<if>|'loopBreak% = 0\nwhile '<bool>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<call> ::= <list_int_var>'.append('<int>')'|<list_int_var>'.insert('<int>','<int>')'|<list_int_var>'.insert(0,'<int>')'|'deleteListItem('<list_int>', '<int>')'|'setListIndexTo('<list_int>', '<int>', '<int>')'|'if rec_counter < 900 and not stop.value:{:'
'rec_counter += 1'
<int_var>' = evolve('<list_int>')'
'rec_counter -= 1'
':}'|'return res0'
<assign> ::= <bool_var>' = '<bool>|<int_assign>|<list_int_var>' = '<list_int>
<for> ::= 'loopBreak% = 0\nfor forCounter% in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in '<list_int>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in '<list_int>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<number> ::= <number><num>|<num><number>|<number><num><number>|<num>
<num> ::= '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
<comp_op> ::= '<'|'>'|'=='|'>='|'<='|'!='|'is'|'is not'
<in_list_comp_op> ::= 'in'|'not in'
<list_comp_op> ::= '=='|'!='
<bool_var> ::= 'b0'|'b1'|'b2'
<bool> ::= <bool_var>|<bool_const>|'(not '<bool>')'|'('<bool>' '<bool_op>' '<bool>')'|'( not '<bool>' and '<bool>')'|'('<bool>' and not '<bool>')'|'('<int>' '<comp_op>' '<int>')'|'bool('<int>')'|'('<int>' '<in_list_comp_op>' '<list_int>')'|'('<list_int>' '<list_comp_op>' '<list_int>')'|'('<list_int>' == [])'
<bool_op> ::= 'and'|'or'|'^'|'=='
<bool_const> ::= 'True'|'False'
<if> ::= 'if '<bool>':{:\n'<code>':}'|'if '<bool>':{:\n'<code>':}else:{:\n'<code>':}'
<int> ::= 'int('<bool>')'|<int_var>|'int('<number>'.0)'|<arith_prefix><int>|'( '<int>' '<arith_ops>' '<int>' )'|<int_arith_ops_protected>'('<int>','<int>')'|'min('<int>', '<int>')'|'max('<int>', '<int>')'|'abs('<int>')'|'('<int>' + 1)'|'('<int>' - 1)'|'getIndexIntList('<list_int>', '<int>')'|'len('<list_int>')'|'getIndexIntList('<list_int>', 0)'|'getIndexIntList('<list_int>', -1)'|'saveIndex('<list_int>', '<int>')'|<list_int>'.count('<int>')'
<int_var> ::= 'i0'|'i1'|'i2'|'res0'
<int_assign> ::= <int_var>' = '<int>|<int_var>' '<arith_ops>'= '<int>
<arith_ops> ::= '+'|'-'|'*'
<int_arith_ops_protected> ::= 'divInt'|'mod'
<arith_prefix> ::= '+'|'-'
<list_int_var> ::= 'li0'|'li1'|'li2'|'in0'
<list_int> ::= <list_int_var>|'list(saveRange('<int>','<int>'))'|<list_int_slice>|'list(reversed('<list_int>'))'|'[x if x == '<int>' else '<int>' for x in '<list_int>']'|'replaceFirstElementInList('<list_int>','<int>','<int>')'|'[x for x in '<list_int>' if x == '<int>']'
<list_int_slice> ::= <list_int>'['<int>':'<int>']'|<list_int>'[:'<int>']'|<list_int>'['<int>':]'|<list_int>'[1:]'|<list_int>'[:1]'
"
Mirror Image,"Given two vectors of integers, return true if one vector is the reverse of the other, and false otherwise.","Write a python function using given grammar without comment, explanation, example usage. Function parameter name has to be in0, in1...(depends on how many parameter it needs), and return variable name has to be res0, res1...(depends on how many parameter it needs).
problem description: Given two vectors of integers, return true if one vector is the reverse of the other, and false otherwise.
problem grammar: <predefined> ::= ""i0 = int(); i1 = int(); i2 = int()""
""b0 = bool(); b1 = bool(); b2 = bool()""
""li0 = []; li1 = []; li2 = []""
""res0 = bool()""
""if 'rec_counter' not in globals():{:""
""globals()['rec_counter'] = 0:}""
""global rec_counter""
<code>
<code> ::= <code><statement>'\n'|<statement>'\n'<code>|<code><statement>'\n'<code>|<statement>'\n'
<statement> ::= <simple_stmt>|<compound_stmt>
<simple_stmt> ::= <call>|<assign>
<compound_stmt> ::= <for>|<if>|'loopBreak% = 0\nwhile '<bool>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<call> ::= <list_int_var>'.append('<int>')'|<list_int_var>'.insert('<int>','<int>')'|<list_int_var>'.insert(0,'<int>')'|'deleteListItem('<list_int>', '<int>')'|'setListIndexTo('<list_int>', '<int>', '<int>')'|'if rec_counter < 900 and not stop.value:{:'
'rec_counter += 1'
<bool_var>' = evolve('<list_int>', '<list_int>')'
'rec_counter -= 1'
':}'|'return res0'
<assign> ::= <bool_var>' = '<bool>|<int_assign>|<list_int_var>' = '<list_int>
<for> ::= 'loopBreak% = 0\nfor forCounter% in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in '<list_int>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in '<list_int>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<number> ::= <number><num>|<num><number>|<number><num><number>|<num>
<num> ::= '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
<comp_op> ::= '<'|'>'|'=='|'>='|'<='|'!='|'is'|'is not'
<in_list_comp_op> ::= 'in'|'not in'
<list_comp_op> ::= '=='|'!='
<bool_var> ::= 'b0'|'b1'|'b2'|'res0'
<bool> ::= <bool_var>|<bool_const>|'(not '<bool>')'|'('<bool>' '<bool_op>' '<bool>')'|'( not '<bool>' and '<bool>')'|'('<bool>' and not '<bool>')'|'('<int>' '<comp_op>' '<int>')'|'bool('<int>')'|'('<int>' '<in_list_comp_op>' '<list_int>')'|'('<list_int>' '<list_comp_op>' '<list_int>')'|'('<list_int>' == [])'
<bool_op> ::= 'and'|'or'|'^'|'=='
<bool_const> ::= 'True'|'False'
<if> ::= 'if '<bool>':{:\n'<code>':}'|'if '<bool>':{:\n'<code>':}else:{:\n'<code>':}'
<int> ::= 'int('<bool>')'|<int_var>|'int('<number>'.0)'|<arith_prefix><int>|'( '<int>' '<arith_ops>' '<int>' )'|<int_arith_ops_protected>'('<int>','<int>')'|'min('<int>', '<int>')'|'max('<int>', '<int>')'|'abs('<int>')'|'('<int>' + 1)'|'('<int>' - 1)'|'getIndexIntList('<list_int>', '<int>')'|'len('<list_int>')'|'getIndexIntList('<list_int>', 0)'|'getIndexIntList('<list_int>', -1)'|'saveIndex('<list_int>', '<int>')'|<list_int>'.count('<int>')'
<int_var> ::= 'i0'|'i1'|'i2'
<int_assign> ::= <int_var>' = '<int>|<int_var>' '<arith_ops>'= '<int>
<arith_ops> ::= '+'|'-'|'*'
<int_arith_ops_protected> ::= 'divInt'|'mod'
<arith_prefix> ::= '+'|'-'
<list_int_var> ::= 'li0'|'li1'|'li2'|'in0'|'in1'
<list_int> ::= <list_int_var>|'list(saveRange('<int>','<int>'))'|<list_int_slice>|'list(reversed('<list_int>'))'|'[x if x == '<int>' else '<int>' for x in '<list_int>']'|'replaceFirstElementInList('<list_int>','<int>','<int>')'|'[x for x in '<list_int>' if x == '<int>']'
<list_int_slice> ::= <list_int>'['<int>':'<int>']'|<list_int>'[:'<int>']'|<list_int>'['<int>':]'|<list_int>'[1:]'|<list_int>'[:1]'
"
Super Anagrams,"Given strings x and y of lowercase letters, return true if y is a super anagram of x, which is the case if every character in x is in y. To be true, y may contain extra characters, but must have at least as many copies of each character as x does.","Write a python function using given grammar without comment, explanation, example usage. Function parameter name has to be in0, in1...(depends on how many parameter it needs), and return variable name has to be res0, res1...(depends on how many parameter it needs).
problem description: Given strings x and y of lowercase letters, return true if y is a super anagram of x, which is the case if every character in x is in y. To be true, y may contain extra characters, but must have at least as many copies of each character as x does.
problem grammar: <predefined> ::= ""i0 = int(); i1 = int(); i2 = int()""
""b0 = bool(); b1 = bool(); b2 = bool()""
""s0 = str(); s1 = str(); s2 = str()""
""c0 = ' '; c1 = ' '; c2 = ' '""
""res0 = bool()""
""if 'rec_counter' not in globals():{:""
""globals()['rec_counter'] = 0:}""
""global rec_counter""
<code>
<code> ::= <code><statement>'\n'|<statement>'\n'<code>|<code><statement>'\n'<code>|<statement>'\n'
<statement> ::= <simple_stmt>|<compound_stmt>
<simple_stmt> ::= <call>|<assign>
<compound_stmt> ::= <for>|<if>|'loopBreak% = 0\nwhile '<bool>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<call> ::= 'if rec_counter < 900 and not stop.value:{:'
'rec_counter += 1'
<bool_var>' = evolve('<string>', '<string>')'
'rec_counter -= 1'
':}'|'return res0'
<assign> ::= <bool_var>' = '<bool>|<int_assign>|<char_var>' = '<char>|<string_var>' = '<string>
<for> ::= 'loopBreak% = 0\nfor forCounter% in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in '<string>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<char_var>' in '<string>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in '<string>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in '<string>'.strip().split():{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in saveSplit('<string>'.strip(), '<string>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<number> ::= <number><num>|<num><number>|<number><num><number>|<num>
<num> ::= '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
<comp_op> ::= '<'|'>'|'=='|'>='|'<='|'!='|'is'|'is not'
<string_const_part> ::= <string_const_part><string_literal>|<string_literal><string_const_part>|<string_const_part><string_literal><string_const_part>|<string_literal>
<bool_var> ::= 'b0'|'b1'|'b2'|'res0'
<bool> ::= <bool_var>|<bool_const>|'(not '<bool>')'|'('<bool>' '<bool_op>' '<bool>')'|'( not '<bool>' and '<bool>')'|'('<bool>' and not '<bool>')'|'('<int>' '<comp_op>' '<int>')'|'bool('<int>')'|<char>'.isdigit()'|<char>'.isspace()'|<char>'.isalpha()'|'('<char>' == '<char>')'|'('<string>' in '<string>')'|'('<string>' not in '<string>')'|'('<string>' == '<string>')'|'('<string>' != '<string>')'|<string>'.startswith('<string>')'|<string>'.endswith('<string>')'|'(not '<string>')'
<bool_op> ::= 'and'|'or'|'^'|'=='
<bool_const> ::= 'True'|'False'
<if> ::= 'if '<bool>':{:\n'<code>':}'|'if '<bool>':{:\n'<code>':}else:{:\n'<code>':}'
<int> ::= 'int('<bool>')'|<int_var>|'int('<number>'.0)'|<arith_prefix><int>|'( '<int>' '<arith_ops>' '<int>' )'|<int_arith_ops_protected>'('<int>','<int>')'|'min('<int>', '<int>')'|'max('<int>', '<int>')'|'abs('<int>')'|'('<int>' + 1)'|'('<int>' - 1)'|'ord('<char>')'|'len('<string>')'|<string>'.count('<char>')'|<string>'.count('<string>')'
<string> ::= 'str('<bool>')'|'str('<int>')'|<char>|<string_var>|""'""<string_const_part>""'""|<string_slice>|'('<string>' + '<string>')'|<string>'.lstrip()'|<string>'.rstrip()'|<string>'.strip()'|<string>'.lstrip('<string>')'|<string>'.rstrip('<string>')'|<string>'.strip('<string>')'|<string>'.capitalize()'|""''.join(reversed(""<string>'))'|<string>'.replace('<string>','<string>', 1)'|<string>'.replace('<string>','<string>')'|<string>'.replace('<char>','<char>', 1)'|<string>'.replace('<char>','<char>')'|<string>'.replace('<char>',"""")'|'setchar('<string>','<char>','<int>')'
<int_var> ::= 'i0'|'i1'|'i2'
<int_assign> ::= <int_var>' = '<int>|<int_var>' '<arith_ops>'= '<int>
<arith_ops> ::= '+'|'-'|'*'
<int_arith_ops_protected> ::= 'divInt'|'mod'
<arith_prefix> ::= '+'|'-'
<char> ::= 'int_to_chr('<int>')'|<char_var>|""'""<char_literal>""'""|'getCharFromString('<string>', '<int>')'
<char_var> ::= 'c0'|'c1'|'c2'
<char_literal> ::= '\\n'|'\\t'|' '|'!'|'""'|'#'|'$'|'%'|'&'|""\\'""|'('|')'|'*'|'+'|','|'-'|'.'|'/'|'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|':'|';'|'<'|'='|'>'|'?'|'@'|'A'|'B'|'C'|'D'|'E'|'F'|'G'|'H'|'I'|'J'|'K'|'L'|'M'|'N'|'O'|'P'|'Q'|'R'|'S'|'T'|'U'|'V'|'W'|'X'|'Y'|'Z'|'['|'\\\\'|']'|'^'|'_'|'`'|'a'|'b'|'c'|'d'|'e'|'f'|'g'|'h'|'i'|'j'|'k'|'l'|'m'|'n'|'o'|'p'|'q'|'r'|'s'|'t'|'u'|'v'|'w'|'x'|'y'|'z'|'{'|'|'|'}'
<string_var> ::= 's0'|'s1'|'s2'|'in0'|'in1'
<string_slice> ::= <string>'['<int>':'<int>']'|<string>'[:'<int>']'|<string>'['<int>':]'|<string>'[1:]'|<string>'[:1]'
<string_literal> ::= ''|'\\n'|'\\t'|' '|'!'|'""'|'#'|'$'|'%'|'&'|""\\'""|'('|')'|'*'|'+'|','|'-'|'.'|'/'|'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|':'|';'|'<'|'='|'>'|'?'|'@'|'A'|'B'|'C'|'D'|'E'|'F'|'G'|'H'|'I'|'J'|'K'|'L'|'M'|'N'|'O'|'P'|'Q'|'R'|'S'|'T'|'U'|'V'|'W'|'X'|'Y'|'Z'|'['|'\\\\'|']'|'^'|'_'|'`'|'a'|'b'|'c'|'d'|'e'|'f'|'g'|'h'|'i'|'j'|'k'|'l'|'m'|'n'|'o'|'p'|'q'|'r'|'s'|'t'|'u'|'v'|'w'|'x'|'y'|'z'|'{'|'|'|'}'
"
Sum of Squares,"Given integer n, return the sum of squaring each integer in the range [1, n].","Write a python function using given grammar without comment, explanation, example usage. Function parameter name has to be in0, in1...(depends on how many parameter it needs), and return variable name has to be res0, res1...(depends on how many parameter it needs).
problem description: Given integer n, return the sum of squaring each integer in the range [1, n].
problem grammar: <predefined> ::= ""i0 = int(); i1 = int(); i2 = int()""
""b0 = bool(); b1 = bool(); b2 = bool()""
""res0 = int()""
""if 'rec_counter' not in globals():{:""
""globals()['rec_counter'] = 0:}""
""global rec_counter""
<code>
<code> ::= <code><statement>'\n'|<statement>'\n'<code>|<code><statement>'\n'<code>|<statement>'\n'
<statement> ::= <simple_stmt>|<compound_stmt>
<simple_stmt> ::= <call>|<assign>
<compound_stmt> ::= <for>|<if>|'loopBreak% = 0\nwhile '<bool>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<call> ::= 'if rec_counter < 900 and not stop.value:{:'
'rec_counter += 1'
<int_var>' = evolve('<int>')'
'rec_counter -= 1'
':}'|'return res0'
<assign> ::= <bool_var>' = '<bool>|<int_assign>
<for> ::= 'loopBreak% = 0\nfor forCounter% in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<number> ::= <number><num>|<num><number>|<number><num><number>|<num>
<num> ::= '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
<comp_op> ::= '<'|'>'|'=='|'>='|'<='|'!='|'is'|'is not'
<bool_var> ::= 'b0'|'b1'|'b2'
<bool> ::= <bool_var>|<bool_const>|'(not '<bool>')'|'('<bool>' '<bool_op>' '<bool>')'|'( not '<bool>' and '<bool>')'|'('<bool>' and not '<bool>')'|'('<int>' '<comp_op>' '<int>')'|'bool('<int>')'
<bool_op> ::= 'and'|'or'|'^'|'=='
<bool_const> ::= 'True'|'False'
<if> ::= 'if '<bool>':{:\n'<code>':}'|'if '<bool>':{:\n'<code>':}else:{:\n'<code>':}'
<int> ::= 'int('<bool>')'|<int_var>|'int('<number>'.0)'|<arith_prefix><int>|'( '<int>' '<arith_ops>' '<int>' )'|<int_arith_ops_protected>'('<int>','<int>')'|'min('<int>', '<int>')'|'max('<int>', '<int>')'|'abs('<int>')'|'('<int>' + 1)'|'('<int>' - 1)'
<int_var> ::= 'i0'|'i1'|'i2'|'res0'|'in0'
<int_assign> ::= <int_var>' = '<int>|<int_var>' '<arith_ops>'= '<int>
<arith_ops> ::= '+'|'-'|'*'
<int_arith_ops_protected> ::= 'divInt'|'mod'
<arith_prefix> ::= '+'|'-'
"
Vectors Summed,"Given two equal-sized vectors of integers, return a vector of integers that contains the sum of the input vectors at each index.","Write a python function using given grammar without comment, explanation, example usage. Function parameter name has to be in0, in1...(depends on how many parameter it needs), and return variable name has to be res0, res1...(depends on how many parameter it needs).
problem description: Given two equal-sized vectors of integers, return a vector of integers that contains the sum of the input vectors at each index.
problem grammar: <predefined> ::= ""i0 = int(); i1 = int(); i2 = int()""
""li0 = []; li1 = []; li2 = []""
""res0 = []""
""if 'rec_counter' not in globals():{:""
""globals()['rec_counter'] = 0:}""
""global rec_counter""
<code>
<code> ::= <code><statement>'\n'|<statement>'\n'<code>|<code><statement>'\n'<code>|<statement>'\n'
<statement> ::= <simple_stmt>|<for>
<simple_stmt> ::= <call>|<assign>
<call> ::= <list_int_var>'.append('<int>')'|<list_int_var>'.insert('<int>','<int>')'|<list_int_var>'.insert(0,'<int>')'|'deleteListItem('<list_int>', '<int>')'|'setListIndexTo('<list_int>', '<int>', '<int>')'|'if rec_counter < 900 and not stop.value:{:'
'rec_counter += 1'
<list_int_var>' = evolve('<list_int>', '<list_int>')'
'rec_counter -= 1'
':}'|'return res0'
<assign> ::= <int_assign>|<list_int_var>' = '<list_int>
<for> ::= 'loopBreak% = 0\nfor forCounter% in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in '<list_int>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in '<list_int>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<number> ::= <number><num>|<num><number>|<number><num><number>|<num>
<num> ::= '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
<int_var> ::= 'i0'|'i1'|'i2'
<int_assign> ::= <int_var>' = '<int>|<int_var>' '<arith_ops>'= '<int>
<int> ::= <int_var>|'int('<number>'.0)'|<arith_prefix><int>|'( '<int>' '<arith_ops>' '<int>' )'|<int_arith_ops_protected>'('<int>','<int>')'|'min('<int>', '<int>')'|'max('<int>', '<int>')'|'abs('<int>')'|'('<int>' + 1)'|'('<int>' - 1)'|'getIndexIntList('<list_int>', '<int>')'|'len('<list_int>')'|'getIndexIntList('<list_int>', 0)'|'getIndexIntList('<list_int>', -1)'|'saveIndex('<list_int>', '<int>')'|<list_int>'.count('<int>')'
<arith_ops> ::= '+'|'-'|'*'
<int_arith_ops_protected> ::= 'divInt'|'mod'
<arith_prefix> ::= '+'|'-'
<list_int_var> ::= 'li0'|'li1'|'li2'|'res0'|'in0'|'in1'
<list_int> ::= <list_int_var>|'list(saveRange('<int>','<int>'))'|<list_int_slice>|'list(reversed('<list_int>'))'|'[x if x == '<int>' else '<int>' for x in '<list_int>']'|'replaceFirstElementInList('<list_int>','<int>','<int>')'|'[x for x in '<list_int>' if x == '<int>']'
<list_int_slice> ::= <list_int>'['<int>':'<int>']'|<list_int>'[:'<int>']'|<list_int>'['<int>':]'|<list_int>'[1:]'|<list_int>'[:1]'
"
X-Word Lines,"Given an integer X and a string that can contain spaces and newlines, return the string with exactly X words per line. The last line may have fewer than X words.","Write a python function using given grammar without comment, explanation, example usage. Function parameter name has to be in0, in1...(depends on how many parameter it needs), and return variable name has to be res0, res1...(depends on how many parameter it needs).
problem description: Given an integer X and a string that can contain spaces and newlines, return the string with exactly X words per line. The last line may have fewer than X words.
problem grammar: <predefined> ::= ""i0 = int(); i1 = int(); i2 = int()""
""b0 = bool(); b1 = bool(); b2 = bool()""
""s0 = str(); s1 = str(); s2 = str()""
""c0 = ' '; c1 = ' '; c2 = ' '""
""res0 = str()""
""if 'rec_counter' not in globals():{:""
""globals()['rec_counter'] = 0:}""
""global rec_counter""
<code>
<code> ::= <code><statement>'\n'|<statement>'\n'<code>|<code><statement>'\n'<code>|<statement>'\n'
<statement> ::= <simple_stmt>|<compound_stmt>
<simple_stmt> ::= <call>|<assign>
<compound_stmt> ::= <for>|<if>|'loopBreak% = 0\nwhile '<bool>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<call> ::= 'if rec_counter < 900 and not stop.value:{:'
'rec_counter += 1'
<string_var>' = evolve('<string>', '<int>')'
'rec_counter -= 1'
':}'|'return res0'
<assign> ::= <bool_var>' = '<bool>|<int_assign>|<char_var>' = '<char>|<string_var>' = '<string>
<for> ::= 'loopBreak% = 0\nfor forCounter% in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in '<string>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<char_var>' in '<string>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in '<string>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in '<string>'.strip().split():{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in saveSplit('<string>'.strip(), '<string>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<number> ::= <number><num>|<num><number>|<number><num><number>|<num>
<num> ::= '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
<comp_op> ::= '<'|'>'|'=='|'>='|'<='|'!='|'is'|'is not'
<string_const_part> ::= <string_const_part><string_literal>|<string_literal><string_const_part>|<string_const_part><string_literal><string_const_part>|<string_literal>
<bool_var> ::= 'b0'|'b1'|'b2'
<bool> ::= <bool_var>|<bool_const>|'(not '<bool>')'|'('<bool>' '<bool_op>' '<bool>')'|'( not '<bool>' and '<bool>')'|'('<bool>' and not '<bool>')'|'('<int>' '<comp_op>' '<int>')'|'bool('<int>')'|<char>'.isdigit()'|<char>'.isspace()'|<char>'.isalpha()'|'('<char>' == '<char>')'|'('<string>' in '<string>')'|'('<string>' not in '<string>')'|'('<string>' == '<string>')'|'('<string>' != '<string>')'|<string>'.startswith('<string>')'|<string>'.endswith('<string>')'|'(not '<string>')'
<bool_op> ::= 'and'|'or'|'^'|'=='
<bool_const> ::= 'True'|'False'
<if> ::= 'if '<bool>':{:\n'<code>':}'|'if '<bool>':{:\n'<code>':}else:{:\n'<code>':}'
<int> ::= 'int('<bool>')'|<int_var>|'int('<number>'.0)'|<arith_prefix><int>|'( '<int>' '<arith_ops>' '<int>' )'|<int_arith_ops_protected>'('<int>','<int>')'|'min('<int>', '<int>')'|'max('<int>', '<int>')'|'abs('<int>')'|'('<int>' + 1)'|'('<int>' - 1)'|'ord('<char>')'|'len('<string>')'|<string>'.count('<char>')'|<string>'.count('<string>')'
<string> ::= 'str('<bool>')'|'str('<int>')'|<char>|<string_var>|""'""<string_const_part>""'""|<string_slice>|'('<string>' + '<string>')'|<string>'.lstrip()'|<string>'.rstrip()'|<string>'.strip()'|<string>'.lstrip('<string>')'|<string>'.rstrip('<string>')'|<string>'.strip('<string>')'|<string>'.capitalize()'|""''.join(reversed(""<string>'))'|<string>'.replace('<string>','<string>', 1)'|<string>'.replace('<string>','<string>')'|<string>'.replace('<char>','<char>', 1)'|<string>'.replace('<char>','<char>')'|<string>'.replace('<char>',"""")'|'setchar('<string>','<char>','<int>')'
<int_var> ::= 'i0'|'i1'|'i2'|'in1'
<int_assign> ::= <int_var>' = '<int>|<int_var>' '<arith_ops>'= '<int>
<arith_ops> ::= '+'|'-'|'*'
<int_arith_ops_protected> ::= 'divInt'|'mod'
<arith_prefix> ::= '+'|'-'
<char> ::= 'int_to_chr('<int>')'|<char_var>|""'""<char_literal>""'""|'getCharFromString('<string>', '<int>')'
<char_var> ::= 'c0'|'c1'|'c2'
<char_literal> ::= '\\n'|'\\t'|' '|'!'|'""'|'#'|'$'|'%'|'&'|""\\'""|'('|')'|'*'|'+'|','|'-'|'.'|'/'|'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|':'|';'|'<'|'='|'>'|'?'|'@'|'A'|'B'|'C'|'D'|'E'|'F'|'G'|'H'|'I'|'J'|'K'|'L'|'M'|'N'|'O'|'P'|'Q'|'R'|'S'|'T'|'U'|'V'|'W'|'X'|'Y'|'Z'|'['|'\\\\'|']'|'^'|'_'|'`'|'a'|'b'|'c'|'d'|'e'|'f'|'g'|'h'|'i'|'j'|'k'|'l'|'m'|'n'|'o'|'p'|'q'|'r'|'s'|'t'|'u'|'v'|'w'|'x'|'y'|'z'|'{'|'|'|'}'
<string_var> ::= 's0'|'s1'|'s2'|'res0'|'in0'
<string_slice> ::= <string>'['<int>':'<int>']'|<string>'[:'<int>']'|<string>'['<int>':]'|<string>'[1:]'|<string>'[:1]'
<string_literal> ::= ''|'\\n'|'\\t'|' '|'!'|'""'|'#'|'$'|'%'|'&'|""\\'""|'('|')'|'*'|'+'|','|'-'|'.'|'/'|'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|':'|';'|'<'|'='|'>'|'?'|'@'|'A'|'B'|'C'|'D'|'E'|'F'|'G'|'H'|'I'|'J'|'K'|'L'|'M'|'N'|'O'|'P'|'Q'|'R'|'S'|'T'|'U'|'V'|'W'|'X'|'Y'|'Z'|'['|'\\\\'|']'|'^'|'_'|'`'|'a'|'b'|'c'|'d'|'e'|'f'|'g'|'h'|'i'|'j'|'k'|'l'|'m'|'n'|'o'|'p'|'q'|'r'|'s'|'t'|'u'|'v'|'w'|'x'|'y'|'z'|'{'|'|'|'}'
"
Pig Latin,"Given a string containing lowercase words separated by single spaces, return the string with each word translated to pig Latin. Specifically, if a word starts with a vowel, it should have “ay” added to its end; otherwise, the first letter is moved to the end of the word, followed by “ay”.","Write a python function using given grammar without comment, explanation, example usage. Function parameter name has to be in0, in1...(depends on how many parameter it needs), and return variable name has to be res0, res1...(depends on how many parameter it needs).
problem description: Given a string containing lowercase words separated by single spaces, return the string with each word translated to pig Latin. Specifically, if a word starts with a vowel, it should have “ay” added to its end; otherwise, the first letter is moved to the end of the word, followed by “ay”.
problem grammar: <predefined> ::= ""i0 = int(); i1 = int(); i2 = int()""
""b0 = bool(); b1 = bool(); b2 = bool()""
""s0 = str(); s1 = str(); s2 = str()""
""c0 = ' '; c1 = ' '; c2 = ' '""
""res0 = str()""
""if 'rec_counter' not in globals():{:""
""globals()['rec_counter'] = 0:}""
""global rec_counter""
<code>
<code> ::= <code><statement>'\n'|<statement>'\n'<code>|<code><statement>'\n'<code>|<statement>'\n'
<statement> ::= <simple_stmt>|<compound_stmt>
<simple_stmt> ::= <call>|<assign>
<compound_stmt> ::= <for>|<if>|'loopBreak% = 0\nwhile '<bool>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<call> ::= 'if rec_counter < 900 and not stop.value:{:'
'rec_counter += 1'
<string_var>' = evolve('<string>')'
'rec_counter -= 1'
':}'|'return res0'
<assign> ::= <bool_var>' = '<bool>|<int_assign>|<char_var>' = '<char>|<string_var>' = '<string>
<for> ::= 'loopBreak% = 0\nfor forCounter% in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in '<string>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<char_var>' in '<string>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in '<string>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in '<string>'.strip().split():{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in saveSplit('<string>'.strip(), '<string>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<number> ::= <number><num>|<num><number>|<number><num><number>|<num>
<num> ::= '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
<comp_op> ::= '<'|'>'|'=='|'>='|'<='|'!='|'is'|'is not'
<string_const_part> ::= <string_const_part><string_literal>|<string_literal><string_const_part>|<string_const_part><string_literal><string_const_part>|<string_literal>
<bool_var> ::= 'b0'|'b1'|'b2'
<bool> ::= <bool_var>|<bool_const>|'(not '<bool>')'|'('<bool>' '<bool_op>' '<bool>')'|'( not '<bool>' and '<bool>')'|'('<bool>' and not '<bool>')'|'('<int>' '<comp_op>' '<int>')'|'bool('<int>')'|<char>'.isdigit()'|<char>'.isspace()'|<char>'.isalpha()'|'('<char>' == '<char>')'|'('<string>' in '<string>')'|'('<string>' not in '<string>')'|'('<string>' == '<string>')'|'('<string>' != '<string>')'|<string>'.startswith('<string>')'|<string>'.endswith('<string>')'|'(not '<string>')'
<bool_op> ::= 'and'|'or'|'^'|'=='
<bool_const> ::= 'True'|'False'
<if> ::= 'if '<bool>':{:\n'<code>':}'|'if '<bool>':{:\n'<code>':}else:{:\n'<code>':}'
<int> ::= 'int('<bool>')'|<int_var>|'int('<number>'.0)'|<arith_prefix><int>|'( '<int>' '<arith_ops>' '<int>' )'|<int_arith_ops_protected>'('<int>','<int>')'|'min('<int>', '<int>')'|'max('<int>', '<int>')'|'abs('<int>')'|'('<int>' + 1)'|'('<int>' - 1)'|'ord('<char>')'|'len('<string>')'|<string>'.count('<char>')'|<string>'.count('<string>')'
<string> ::= 'str('<bool>')'|'str('<int>')'|<char>|<string_var>|<string_const>|<string_slice>|'('<string>' + '<string>')'|<string>'.lstrip()'|<string>'.rstrip()'|<string>'.strip()'|<string>'.lstrip('<string>')'|<string>'.rstrip('<string>')'|<string>'.strip('<string>')'|<string>'.capitalize()'|""''.join(reversed(""<string>'))'|<string>'.replace('<string>','<string>', 1)'|<string>'.replace('<string>','<string>')'|<string>'.replace('<char>','<char>', 1)'|<string>'.replace('<char>','<char>')'|<string>'.replace('<char>',"""")'|'setchar('<string>','<char>','<int>')'
<int_var> ::= 'i0'|'i1'|'i2'
<int_assign> ::= <int_var>' = '<int>|<int_var>' '<arith_ops>'= '<int>
<arith_ops> ::= '+'|'-'|'*'
<int_arith_ops_protected> ::= 'divInt'|'mod'
<arith_prefix> ::= '+'|'-'
<char> ::= 'int_to_chr('<int>')'|<char_var>|""'""<char_literal>""'""|'getCharFromString('<string>', '<int>')'
<char_var> ::= 'c0'|'c1'|'c2'
<char_literal> ::= '\\n'|'\\t'|' '|'!'|'""'|'#'|'$'|'%'|'&'|""\\'""|'('|')'|'*'|'+'|','|'-'|'.'|'/'|'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|':'|';'|'<'|'='|'>'|'?'|'@'|'A'|'B'|'C'|'D'|'E'|'F'|'G'|'H'|'I'|'J'|'K'|'L'|'M'|'N'|'O'|'P'|'Q'|'R'|'S'|'T'|'U'|'V'|'W'|'X'|'Y'|'Z'|'['|'\\\\'|']'|'^'|'_'|'`'|'a'|'b'|'c'|'d'|'e'|'f'|'g'|'h'|'i'|'j'|'k'|'l'|'m'|'n'|'o'|'p'|'q'|'r'|'s'|'t'|'u'|'v'|'w'|'x'|'y'|'z'|'{'|'|'|'}'|'a'|'e'|'i'|'o'|'u'
<string_var> ::= 's0'|'s1'|'s2'|'res0'|'in0'
<string_slice> ::= <string>'['<int>':'<int>']'|<string>'[:'<int>']'|<string>'['<int>':]'|<string>'[1:]'|<string>'[:1]'
<string_const> ::= ""'""<string_const_part>""'""|""'ay'""|""'aeiou'""
<string_literal> ::= ''|'\\n'|'\\t'|' '|'!'|'""'|'#'|'$'|'%'|'&'|""\\'""|'('|')'|'*'|'+'|','|'-'|'.'|'/'|'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|':'|';'|'<'|'='|'>'|'?'|'@'|'A'|'B'|'C'|'D'|'E'|'F'|'G'|'H'|'I'|'J'|'K'|'L'|'M'|'N'|'O'|'P'|'Q'|'R'|'S'|'T'|'U'|'V'|'W'|'X'|'Y'|'Z'|'['|'\\\\'|']'|'^'|'_'|'`'|'a'|'b'|'c'|'d'|'e'|'f'|'g'|'h'|'i'|'j'|'k'|'l'|'m'|'n'|'o'|'p'|'q'|'r'|'s'|'t'|'u'|'v'|'w'|'x'|'y'|'z'|'{'|'|'|'}'
"
Negative To Zero,"Given a vector of integers, return the vector where all negative integers have been replaced by 0.","Write a python function using given grammar without comment, explanation, example usage. Function parameter name has to be in0, in1...(depends on how many parameter it needs), and return variable name has to be res0, res1...(depends on how many parameter it needs).
problem description: Given a vector of integers, return the vector where all negative integers have been replaced by 0.
problem grammar: <predefined> ::= ""i0 = int(); i1 = int(); i2 = int()""
""b0 = bool(); b1 = bool(); b2 = bool()""
""li0 = []; li1 = []; li2 = []""
""res0 = []""
""if 'rec_counter' not in globals():{:""
""globals()['rec_counter'] = 0:}""
""global rec_counter""
<code>
<code> ::= <code><statement>'\n'|<statement>'\n'<code>|<code><statement>'\n'<code>|<statement>'\n'
<statement> ::= <simple_stmt>|<compound_stmt>
<simple_stmt> ::= <call>|<assign>
<compound_stmt> ::= <for>|<if>|'loopBreak% = 0\nwhile '<bool>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<call> ::= <list_int_var>'.append('<int>')'|<list_int_var>'.insert('<int>','<int>')'|<list_int_var>'.insert(0,'<int>')'|'deleteListItem('<list_int>', '<int>')'|'setListIndexTo('<list_int>', '<int>', '<int>')'|'if rec_counter < 900 and not stop.value:{:'
'rec_counter += 1'
<list_int_var>' = evolve('<list_int>')'
'rec_counter -= 1'
':}'|'return res0'
<assign> ::= <bool_var>' = '<bool>|<int_assign>|<list_int_var>' = '<list_int>
<for> ::= 'loopBreak% = 0\nfor forCounter% in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in '<list_int>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in '<list_int>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<number> ::= <number><num>|<num><number>|<number><num><number>|<num>
<num> ::= '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
<comp_op> ::= '<'|'>'|'=='|'>='|'<='|'!='|'is'|'is not'
<in_list_comp_op> ::= 'in'|'not in'
<list_comp_op> ::= '=='|'!='
<bool_var> ::= 'b0'|'b1'|'b2'
<bool> ::= <bool_var>|<bool_const>|'(not '<bool>')'|'('<bool>' '<bool_op>' '<bool>')'|'( not '<bool>' and '<bool>')'|'('<bool>' and not '<bool>')'|'('<int>' '<comp_op>' '<int>')'|'bool('<int>')'|'('<int>' '<in_list_comp_op>' '<list_int>')'|'('<list_int>' '<list_comp_op>' '<list_int>')'|'('<list_int>' == [])'
<bool_op> ::= 'and'|'or'|'^'|'=='
<bool_const> ::= 'True'|'False'
<if> ::= 'if '<bool>':{:\n'<code>':}'|'if '<bool>':{:\n'<code>':}else:{:\n'<code>':}'
<int> ::= 'int('<bool>')'|<int_var>|'int('<number>'.0)'|<arith_prefix><int>|'( '<int>' '<arith_ops>' '<int>' )'|<int_arith_ops_protected>'('<int>','<int>')'|'min('<int>', '<int>')'|'max('<int>', '<int>')'|'abs('<int>')'|'('<int>' + 1)'|'('<int>' - 1)'|'getIndexIntList('<list_int>', '<int>')'|'len('<list_int>')'|'getIndexIntList('<list_int>', 0)'|'getIndexIntList('<list_int>', -1)'|'saveIndex('<list_int>', '<int>')'|<list_int>'.count('<int>')'
<int_var> ::= 'i0'|'i1'|'i2'
<int_assign> ::= <int_var>' = '<int>|<int_var>' '<arith_ops>'= '<int>
<arith_ops> ::= '+'|'-'|'*'
<int_arith_ops_protected> ::= 'divInt'|'mod'
<arith_prefix> ::= '+'|'-'
<list_int_var> ::= 'li0'|'li1'|'li2'|'res0'|'in0'
<list_int> ::= <list_int_var>|'list(saveRange('<int>','<int>'))'|<list_int_slice>|'list(reversed('<list_int>'))'|'[x if x == '<int>' else '<int>' for x in '<list_int>']'|'replaceFirstElementInList('<list_int>','<int>','<int>')'|'[x for x in '<list_int>' if x == '<int>']'
<list_int_slice> ::= <list_int>'['<int>':'<int>']'|<list_int>'[:'<int>']'|<list_int>'['<int>':]'|<list_int>'[1:]'|<list_int>'[:1]'
"
Scrabble Score,"Given a string of visible ASCII characters, return the Scrabble score for that string. Each letter has a corresponding value according to normal Scrabble rules, and non-letter characters are worth zero.","Write a python function using given grammar without comment, explanation, example usage. Function parameter name has to be in0, in1...(depends on how many parameter it needs), and return variable name has to be res0, res1...(depends on how many parameter it needs).
problem description: Given a string of visible ASCII characters, return the Scrabble score for that string. Each letter has a corresponding value according to normal Scrabble rules, and non-letter characters are worth zero.
problem grammar: <predefined> ::= ""i0 = int(); i1 = int(); i2 = int()""
""b0 = bool(); b1 = bool(); b2 = bool()""
""s0 = str(); s1 = str(); s2 = str()""
""c0 = ' '; c1 = ' '; c2 = ' '""
""li0 = []; li1 = []; li2 = []""
""res0 = int()""
""if 'rec_counter' not in globals():{:""
""globals()['rec_counter'] = 0:}""
""global rec_counter""
<code>
<code> ::= <code><statement>'\n'|<statement>'\n'<code>|<code><statement>'\n'<code>|<statement>'\n'
<statement> ::= <simple_stmt>|<compound_stmt>|'li0 = [1, 3, 3, 2, 1, 4, 2, 4, 1, 8, 5, 1, 3, 1, 1, 3, 10, 1, 1, 1, 1, 1, 4, 4, 8, 4, 10]'
<simple_stmt> ::= <call>|<assign>
<compound_stmt> ::= <for>|<if>|'loopBreak% = 0\nwhile '<bool>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<call> ::= <list_int_var>'.append('<int>')'|<list_int_var>'.insert('<int>','<int>')'|<list_int_var>'.insert(0,'<int>')'|'deleteListItem('<list_int>', '<int>')'|'setListIndexTo('<list_int>', '<int>', '<int>')'|'if rec_counter < 900 and not stop.value:{:'
'rec_counter += 1'
<int_var>' = evolve('<string>')'
'rec_counter -= 1'
':}'|'return res0'
<assign> ::= <bool_var>' = '<bool>|<int_assign>|<char_var>' = '<char>|<string_var>' = '<string>|<list_int_var>' = '<list_int>
<for> ::= 'loopBreak% = 0\nfor forCounter% in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in '<string>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<char_var>' in '<string>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in '<string>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in '<string>'.strip().split():{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in saveSplit('<string>'.strip(), '<string>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in '<list_int>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in '<list_int>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<number> ::= <number><num>|<num><number>|<number><num><number>|<num>
<num> ::= '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
<comp_op> ::= '<'|'>'|'=='|'>='|'<='|'!='|'is'|'is not'
<string_const_part> ::= <string_const_part><string_literal>|<string_literal><string_const_part>|<string_const_part><string_literal><string_const_part>|<string_literal>
<in_list_comp_op> ::= 'in'|'not in'
<list_comp_op> ::= '=='|'!='
<bool_var> ::= 'b0'|'b1'|'b2'
<bool> ::= <bool_var>|<bool_const>|'(not '<bool>')'|'('<bool>' '<bool_op>' '<bool>')'|'( not '<bool>' and '<bool>')'|'('<bool>' and not '<bool>')'|'('<int>' '<comp_op>' '<int>')'|'bool('<int>')'|<char>'.isdigit()'|<char>'.isspace()'|<char>'.isalpha()'|'('<char>' == '<char>')'|'('<string>' in '<string>')'|'('<string>' not in '<string>')'|'('<string>' == '<string>')'|'('<string>' != '<string>')'|<string>'.startswith('<string>')'|<string>'.endswith('<string>')'|'(not '<string>')'|'('<int>' '<in_list_comp_op>' '<list_int>')'|'('<list_int>' '<list_comp_op>' '<list_int>')'|'('<list_int>' == [])'
<bool_op> ::= 'and'|'or'|'^'|'=='
<bool_const> ::= 'True'|'False'
<if> ::= 'if '<bool>':{:\n'<code>':}'|'if '<bool>':{:\n'<code>':}else:{:\n'<code>':}'
<int> ::= 'int('<bool>')'|<int_var>|'int('<number>'.0)'|<arith_prefix><int>|'( '<int>' '<arith_ops>' '<int>' )'|<int_arith_ops_protected>'('<int>','<int>')'|'min('<int>', '<int>')'|'max('<int>', '<int>')'|'abs('<int>')'|'('<int>' + 1)'|'('<int>' - 1)'|'ord('<char>')'|'len('<string>')'|<string>'.count('<char>')'|<string>'.count('<string>')'|'getIndexIntList('<list_int>', '<int>')'|'len('<list_int>')'|'getIndexIntList('<list_int>', 0)'|'getIndexIntList('<list_int>', -1)'|'saveIndex('<list_int>', '<int>')'|<list_int>'.count('<int>')'
<string> ::= 'str('<bool>')'|'str('<int>')'|<char>|<string_var>|""'""<string_const_part>""'""|<string_slice>|'('<string>' + '<string>')'|<string>'.lstrip()'|<string>'.rstrip()'|<string>'.strip()'|<string>'.lstrip('<string>')'|<string>'.rstrip('<string>')'|<string>'.strip('<string>')'|<string>'.capitalize()'|""''.join(reversed(""<string>'))'|<string>'.replace('<string>','<string>', 1)'|<string>'.replace('<string>','<string>')'|<string>'.replace('<char>','<char>', 1)'|<string>'.replace('<char>','<char>')'|<string>'.replace('<char>',"""")'|'setchar('<string>','<char>','<int>')'
<int_var> ::= 'i0'|'i1'|'i2'|'res0'
<int_assign> ::= <int_var>' = '<int>|<int_var>' '<arith_ops>'= '<int>
<arith_ops> ::= '+'|'-'|'*'
<int_arith_ops_protected> ::= 'divInt'|'mod'
<arith_prefix> ::= '+'|'-'
<char> ::= 'int_to_chr('<int>')'|<char_var>|""'""<char_literal>""'""|'getCharFromString('<string>', '<int>')'
<char_var> ::= 'c0'|'c1'|'c2'
<char_literal> ::= '\\n'|'\\t'|' '|'!'|'""'|'#'|'$'|'%'|'&'|""\\'""|'('|')'|'*'|'+'|','|'-'|'.'|'/'|'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|':'|';'|'<'|'='|'>'|'?'|'@'|'A'|'B'|'C'|'D'|'E'|'F'|'G'|'H'|'I'|'J'|'K'|'L'|'M'|'N'|'O'|'P'|'Q'|'R'|'S'|'T'|'U'|'V'|'W'|'X'|'Y'|'Z'|'['|'\\\\'|']'|'^'|'_'|'`'|'a'|'b'|'c'|'d'|'e'|'f'|'g'|'h'|'i'|'j'|'k'|'l'|'m'|'n'|'o'|'p'|'q'|'r'|'s'|'t'|'u'|'v'|'w'|'x'|'y'|'z'|'{'|'|'|'}'
<string_var> ::= 's0'|'s1'|'s2'|'in0'
<string_slice> ::= <string>'['<int>':'<int>']'|<string>'[:'<int>']'|<string>'['<int>':]'|<string>'[1:]'|<string>'[:1]'
<string_literal> ::= ''|'\\n'|'\\t'|' '|'!'|'""'|'#'|'$'|'%'|'&'|""\\'""|'('|')'|'*'|'+'|','|'-'|'.'|'/'|'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|':'|';'|'<'|'='|'>'|'?'|'@'|'A'|'B'|'C'|'D'|'E'|'F'|'G'|'H'|'I'|'J'|'K'|'L'|'M'|'N'|'O'|'P'|'Q'|'R'|'S'|'T'|'U'|'V'|'W'|'X'|'Y'|'Z'|'['|'\\\\'|']'|'^'|'_'|'`'|'a'|'b'|'c'|'d'|'e'|'f'|'g'|'h'|'i'|'j'|'k'|'l'|'m'|'n'|'o'|'p'|'q'|'r'|'s'|'t'|'u'|'v'|'w'|'x'|'y'|'z'|'{'|'|'|'}'
<list_int_var> ::= 'li0'|'li1'|'li2'
<list_int> ::= <list_int_var>|'list(saveRange('<int>','<int>'))'|<list_int_slice>|'list(reversed('<list_int>'))'|'[x if x == '<int>' else '<int>' for x in '<list_int>']'|'replaceFirstElementInList('<list_int>','<int>','<int>')'|'[x for x in '<list_int>' if x == '<int>']'
<list_int_slice> ::= <list_int>'['<int>':'<int>']'|<list_int>'[:'<int>']'|<list_int>'['<int>':]'|<list_int>'[1:]'|<list_int>'[:1]'"
Word Stats,"Given a string, return the number of words containing n characters for n from 1 to the length of the longest word, in a list.
At the end of the output, return the number of sentences and the average sentence length. 
A word is any string of consecutive non-whitespace characters (including sentence terminators). Every file will contain at least one sentence terminator (period, exclamation point, or question mark). The average sentence length is the number of words in the file divided by the number of sentence terminator characters.","Write a python function using given grammar without comment, explanation, example usage. Function parameter name has to be in0, in1...(depends on how many parameter it needs), and return variable name has to be res0, res1...(depends on how many parameter it needs).
problem description: Given a string, return the number of words containing n characters for n from 1 to the length of the longest word, in a list.
At the end of the output, return the number of sentences and the average sentence length. 
A word is any string of consecutive non-whitespace characters (including sentence terminators). Every file will contain at least one sentence terminator (period, exclamation point, or question mark). The average sentence length is the number of words in the file divided by the number of sentence terminator characters.
problem grammar: <predefined> ::= ""i0 = int(); i1 = int(); i2 = int()""
""b0 = bool(); b1 = bool(); b2 = bool()""
""f0 = float(); f1 = float(); f2 = float()""
""s0 = str(); s1 = str(); s2 = str()""
""c0 = ' '; c1 = ' '; c2 = ' '""
""li0 = []; li1 = []; li2 = []""
""lf0 = []; lf1 = []; lf2 = []""
""ls0 = []; ls1 = []; ls2 = []""
""res0 = []; res1 = int(); res2 = float()""
""if 'rec_counter' not in globals():{:""
""globals()['rec_counter'] = 0:}""
""global rec_counter""
<code>
<code> ::= <code><statement>'\n'|<statement>'\n'<code>|<code><statement>'\n'<code>|<statement>'\n'
<statement> ::= <simple_stmt>|<compound_stmt>
<simple_stmt> ::= <call>|<assign>
<compound_stmt> ::= <for>|<if>|'loopBreak% = 0\nwhile '<bool>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<call> ::= <list_int_var>'.append('<int>')'|<list_int_var>'.insert('<int>','<int>')'|<list_int_var>'.insert(0,'<int>')'|'deleteListItem('<list_int>', '<int>')'|'setListIndexTo('<list_int>', '<int>', '<int>')'|<list_float_var>'.append('<float>')'|<list_float_var>'.insert('<int>','<float>')'|<list_float_var>'.insert(0,'<float>')'|'deleteListItem('<list_float>', '<int>')'|'setListIndexTo('<list_float>', '<int>', '<float>')'|<list_string_var>'.insert('<int>','<string>')'|'deleteListItem('<list_string>', '<int>')'|'setListIndexTo('<list_string>', '<int>', '<string>')'|<list_string_var>'.append('<string>')'|<list_string_var>'.insert('<int>','<string>')'|<list_string_var>'.insert(0,'<string>')'|'deleteListItem('<list_string>', '<int>')'|'setListIndexTo('<list_string>', '<int>', '<string>')'|'if rec_counter < 900 and not stop.value:{:'
'rec_counter += 1'
<list_int_var>', '<int_var>', '<float_var>' = evolve('<string>')'
'rec_counter -= 1'
':}'|'return res0, res1, res2'
<assign> ::= <bool_var>' = '<bool>|<int_assign>|<float_assign>|<char_var>' = '<char>|<string_var>' = '<string>|<list_int_var>' = '<list_int>|<list_float_var>' = '<list_float>|<list_string_var>' = '<list_string>
<for> ::= 'loopBreak% = 0\nfor forCounter% in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in '<string>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<char_var>' in '<string>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in '<string>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in '<string>'.strip().split():{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in saveSplit('<string>'.strip(), '<string>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in '<list_int>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in '<list_int>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in '<list_float>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<float_var>' in '<list_float>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in '<list_string>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in '<list_string>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<number> ::= <number><num>|<num><number>|<number><num><number>|<num>
<num> ::= '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
<comp_op> ::= '<'|'>'|'=='|'>='|'<='|'!='|'is'|'is not'
<string_const_part> ::= <string_const_part><string_literal>|<string_literal><string_const_part>|<string_const_part><string_literal><string_const_part>|<string_literal>
<in_list_comp_op> ::= 'in'|'not in'
<list_comp_op> ::= '=='|'!='
<bool_var> ::= 'b0'|'b1'|'b2'
<bool> ::= <bool_var>|<bool_const>|'(not '<bool>')'|'('<bool>' '<bool_op>' '<bool>')'|'( not '<bool>' and '<bool>')'|'('<bool>' and not '<bool>')'|'('<int>' '<comp_op>' '<int>')'|'bool('<int>')'|'('<float>' '<comp_op>' '<float>')'|'bool('<float>')'|<char>'.isdigit()'|<char>'.isspace()'|<char>'.isalpha()'|'('<char>' == '<char>')'|'('<string>' in '<string>')'|'('<string>' not in '<string>')'|'('<string>' == '<string>')'|'('<string>' != '<string>')'|<string>'.startswith('<string>')'|<string>'.endswith('<string>')'|'(not '<string>')'|'('<int>' '<in_list_comp_op>' '<list_int>')'|'('<list_int>' '<list_comp_op>' '<list_int>')'|'('<list_int>' == [])'|'('<float>' '<in_list_comp_op>' '<list_float>')'|'('<list_float>' '<list_comp_op>' '<list_float>')'|'('<list_float>' == [])'|'('<string>' '<in_list_comp_op>' '<list_string>')'|'('<list_string>' '<list_comp_op>' '<list_string>')'|'('<list_string>' == [])'
<bool_op> ::= 'and'|'or'|'^'|'=='
<bool_const> ::= 'True'|'False'
<if> ::= 'if '<bool>':{:\n'<code>':}'|'if '<bool>':{:\n'<code>':}else:{:\n'<code>':}'
<int> ::= 'int('<bool>')'|<int_var>|'int('<number>'.0)'|<arith_prefix><int>|'( '<int>' '<arith_ops>' '<int>' )'|<int_arith_ops_protected>'('<int>','<int>')'|'min('<int>', '<int>')'|'max('<int>', '<int>')'|'abs('<int>')'|'('<int>' + 1)'|'('<int>' - 1)'|'int(math.ceil('<float>'))'|'int(math.floor('<float>'))'|'int(round('<float>'))'|'int('<float>')'|'ord('<char>')'|'len('<string>')'|<string>'.count('<char>')'|<string>'.count('<string>')'|'getIndexIntList('<list_int>', '<int>')'|'len('<list_int>')'|'getIndexIntList('<list_int>', 0)'|'getIndexIntList('<list_int>', -1)'|'saveIndex('<list_int>', '<int>')'|<list_int>'.count('<int>')'|'len('<list_float>')'|'saveIndex('<list_float>', '<float>')'|<list_float>'.count('<float>')'|'len('<list_string>')'|'saveIndex('<list_string>', '<string>')'|<list_string>'.count('<string>')'
<float> ::= 'float('<bool>')'|<int>|<float_var>|<number>'.'<number>|<arith_prefix><float>|'('<float>' '<arith_ops>' '<float>')'|<float_arith_ops_protected>'('<float>','<float>')'|'math.ceil('<float>')'|'math.floor('<float>')'|'round('<float>')'|'min('<float>', '<float>')'|'max('<float>', '<float>')'|'abs('<float>')'|'math.sin('<float>')'|'math.cos('<float>')'|'math.tan('<float>')'|'('<float>' + 1)'|'('<float>' - 1)'|'getIndexFloatList('<list_float>', '<int>')'|'getIndexFloatList('<list_float>', 0)'|'getIndexFloatList('<list_float>', -1)'
<string> ::= 'str('<bool>')'|'str('<int>')'|'str('<float>')'|<char>|<string_var>|""'""<string_const_part>""'""|<string_slice>|'('<string>' + '<string>')'|<string>'.lstrip()'|<string>'.rstrip()'|<string>'.strip()'|<string>'.lstrip('<string>')'|<string>'.rstrip('<string>')'|<string>'.strip('<string>')'|<string>'.capitalize()'|""''.join(reversed(""<string>'))'|<string>'.replace('<string>','<string>', 1)'|<string>'.replace('<string>','<string>')'|<string>'.replace('<char>','<char>', 1)'|<string>'.replace('<char>','<char>')'|<string>'.replace('<char>',"""")'|'setchar('<string>','<char>','<int>')'|<string>'.join('<list_string>')'|'getIndexStringList('<list_string>', '<int>')'|'getIndexStringList('<list_string>', 0)'|'getIndexStringList('<list_string>', -1)'
<int_var> ::= 'i0'|'i1'|'i2'|'res1'
<int_assign> ::= <int_var>' = '<int>|<int_var>' '<arith_ops>'= '<int>
<arith_ops> ::= '+'|'-'|'*'
<int_arith_ops_protected> ::= 'divInt'|'mod'
<arith_prefix> ::= '+'|'-'
<char> ::= 'int_to_chr('<int>')'|'float_to_chr('<float>')'|<char_var>|""'""<char_literal>""'""|'getCharFromString('<string>', '<int>')'
<float_var> ::= 'f0'|'f1'|'f2'|'res2'
<float_assign> ::= <float_var>' = '<float>|<float_var>' '<arith_ops>'= '<float>
<float_arith_ops_protected> ::= 'div'|'divInt'|'mod'
<char_var> ::= 'c0'|'c1'|'c2'
<char_literal> ::= '\\n'|'\\t'|' '|'!'|'""'|'#'|'$'|'%'|'&'|""\\'""|'('|')'|'*'|'+'|','|'-'|'.'|'/'|'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|':'|';'|'<'|'='|'>'|'?'|'@'|'A'|'B'|'C'|'D'|'E'|'F'|'G'|'H'|'I'|'J'|'K'|'L'|'M'|'N'|'O'|'P'|'Q'|'R'|'S'|'T'|'U'|'V'|'W'|'X'|'Y'|'Z'|'['|'\\\\'|']'|'^'|'_'|'`'|'a'|'b'|'c'|'d'|'e'|'f'|'g'|'h'|'i'|'j'|'k'|'l'|'m'|'n'|'o'|'p'|'q'|'r'|'s'|'t'|'u'|'v'|'w'|'x'|'y'|'z'|'{'|'|'|'}'
<string_var> ::= 's0'|'s1'|'s2'|'in0'
<string_slice> ::= <string>'['<int>':'<int>']'|<string>'[:'<int>']'|<string>'['<int>':]'|<string>'[1:]'|<string>'[:1]'
<string_literal> ::= ''|'\\n'|'\\t'|' '|'!'|'""'|'#'|'$'|'%'|'&'|""\\'""|'('|')'|'*'|'+'|','|'-'|'.'|'/'|'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|':'|';'|'<'|'='|'>'|'?'|'@'|'A'|'B'|'C'|'D'|'E'|'F'|'G'|'H'|'I'|'J'|'K'|'L'|'M'|'N'|'O'|'P'|'Q'|'R'|'S'|'T'|'U'|'V'|'W'|'X'|'Y'|'Z'|'['|'\\\\'|']'|'^'|'_'|'`'|'a'|'b'|'c'|'d'|'e'|'f'|'g'|'h'|'i'|'j'|'k'|'l'|'m'|'n'|'o'|'p'|'q'|'r'|'s'|'t'|'u'|'v'|'w'|'x'|'y'|'z'|'{'|'|'|'}'
<list_string> ::= <string>'.strip().split()'|'saveSplit('<string>'.strip(), '<string>')'|<list_string_var>|<list_string_slice>|'saveSplit('<string>','<string>')'|'list(reversed('<list_string>'))'|'[x if x == '<string>' else '<string>' for x in '<list_string>']'|'replaceFirstElementInList('<list_string>','<string>','<string>')'|'[x for x in '<list_string>' if x == '<string>']'
<list_int_var> ::= 'li0'|'li1'|'li2'|'res0'
<list_int> ::= <list_int_var>|'list(saveRange('<int>','<int>'))'|<list_int_slice>|'list(reversed('<list_int>'))'|'[x if x == '<int>' else '<int>' for x in '<list_int>']'|'replaceFirstElementInList('<list_int>','<int>','<int>')'|'[x for x in '<list_int>' if x == '<int>']'
<list_int_slice> ::= <list_int>'['<int>':'<int>']'|<list_int>'[:'<int>']'|<list_int>'['<int>':]'|<list_int>'[1:]'|<list_int>'[:1]'
<list_float_var> ::= 'lf0'|'lf1'|'lf2'
<list_float> ::= <list_float_var>|<list_float_slice>|'list(reversed('<list_float>'))'|'[x if x == '<float>' else '<float>' for x in '<list_float>']'|'replaceFirstElementInList('<list_float>','<float>','<float>')'|'[x for x in '<list_float>' if x == '<float>']'
<list_float_slice> ::= <list_float>'['<int>':'<int>']'|<list_float>'[:'<int>']'|<list_float>'['<int>':]'|<list_float>'[1:]'|<list_float>'[:1]'
<list_string_var> ::= 'ls0'|'ls1'|'ls2'
<list_string_slice> ::= <list_string>'['<int>':'<int>']'|<list_string>'[:'<int>']'|<list_string>'['<int>':]'|<list_string>'[1:]'|<list_string>'[:1]'
"
Checksum,"Given a string, convert each character in the string into its integer ASCII value, sum them, take the sum modulo 64, add the integer value of the space character, and then convert that integer back into its corresponding character (the checksum character) and return. ","Write a python function using given grammar without comment, explanation, example usage. Function parameter name has to be in0, in1...(depends on how many parameter it needs), and return variable name has to be res0, res1...(depends on how many parameter it needs).
problem description: Given a string, convert each character in the string into its integer ASCII value, sum them, take the sum modulo 64, add the integer value of the space character, and then convert that integer back into its corresponding character (the checksum character) and return. 
problem grammar: <predefined> ::= ""b0 = bool(); b1 = bool(); b2 = bool()""
""i0 = int(); i1 = int(); i2 = int()""
""s0 = str(); s1 = str(); s2 = str()""
""c0 = ' '; c1 = ' '; c2 = ' '""
""res0 = ' '""
""if 'rec_counter' not in globals():{:""
""globals()['rec_counter'] = 0:}""
""global rec_counter""
<code>
<code> ::= <code><statement>'\n'|<statement>'\n'<code>|<code><statement>'\n'<code>|<statement>'\n'
<statement> ::= <simple_stmt>|<compound_stmt>
<simple_stmt> ::= <call>|<assign>
<compound_stmt> ::= <for>|<if>|'loopBreak% = 0\nwhile '<bool>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<call> ::= 'if rec_counter < 900 and not stop.value:{:'
'rec_counter += 1'
<char_var>' = evolve('<string>')'
'rec_counter -= 1'
':}'|'return res0'
<assign> ::= <bool_var>' = '<bool>|<int_assign>|<char_var>' = '<char>|<string_var>' = '<string>
<for> ::= 'loopBreak% = 0\nfor forCounter% in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in '<string>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<char_var>' in '<string>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in '<string>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in '<string>'.strip().split():{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in saveSplit('<string>'.strip(), '<string>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<number> ::= <number><num>|<num><number>|<number><num><number>|<num>
<num> ::= '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
<comp_op> ::= '<'|'>'|'=='|'>='|'<='|'!='|'is'|'is not'
<string_const_part> ::= <string_const_part><string_literal>|<string_literal><string_const_part>|<string_const_part><string_literal><string_const_part>|<string_literal>
<bool_var> ::= 'b0'|'b1'|'b2'
<bool> ::= <bool_var>|<bool_const>|'(not '<bool>')'|'('<bool>' '<bool_op>' '<bool>')'|'( not '<bool>' and '<bool>')'|'('<bool>' and not '<bool>')'|'('<int>' '<comp_op>' '<int>')'|'bool('<int>')'|<char>'.isdigit()'|<char>'.isspace()'|<char>'.isalpha()'|'('<char>' == '<char>')'|'('<string>' in '<string>')'|'('<string>' not in '<string>')'|'('<string>' == '<string>')'|'('<string>' != '<string>')'|<string>'.startswith('<string>')'|<string>'.endswith('<string>')'|'(not '<string>')'
<bool_op> ::= 'and'|'or'|'^'|'=='
<bool_const> ::= 'True'|'False'
<if> ::= 'if '<bool>':{:\n'<code>':}'|'if '<bool>':{:\n'<code>':}else:{:\n'<code>':}'
<int> ::= 'int('<bool>')'|<int_var>|'int('<number>'.0)'|<arith_prefix><int>|'( '<int>' '<arith_ops>' '<int>' )'|<int_arith_ops_protected>'('<int>','<int>')'|'min('<int>', '<int>')'|'max('<int>', '<int>')'|'abs('<int>')'|'('<int>' + 1)'|'('<int>' - 1)'|'ord('<char>')'|'len('<string>')'|<string>'.count('<char>')'|<string>'.count('<string>')'
<string> ::= 'str('<bool>')'|'str('<int>')'|<char>|<string_var>|""'""<string_const_part>""'""|<string_slice>|'('<string>' + '<string>')'|<string>'.lstrip()'|<string>'.rstrip()'|<string>'.strip()'|<string>'.lstrip('<string>')'|<string>'.rstrip('<string>')'|<string>'.strip('<string>')'|<string>'.capitalize()'|""''.join(reversed(""<string>'))'|<string>'.replace('<string>','<string>', 1)'|<string>'.replace('<string>','<string>')'|<string>'.replace('<char>','<char>', 1)'|<string>'.replace('<char>','<char>')'|<string>'.replace('<char>',"""")'|'setchar('<string>','<char>','<int>')'
<int_var> ::= 'i0'|'i1'|'i2'
<int_assign> ::= <int_var>' = '<int>|<int_var>' '<arith_ops>'= '<int>
<arith_ops> ::= '+'|'-'|'*'
<int_arith_ops_protected> ::= 'divInt'|'mod'
<arith_prefix> ::= '+'|'-'
<char> ::= 'int_to_chr('<int>')'|<char_var>|""'""<char_literal>""'""|'getCharFromString('<string>', '<int>')'
<char_var> ::= 'c0'|'c1'|'c2'|'res0'
<char_literal> ::= '\\n'|'\\t'|' '|'!'|'""'|'#'|'$'|'%'|'&'|""\\'""|'('|')'|'*'|'+'|','|'-'|'.'|'/'|'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|':'|';'|'<'|'='|'>'|'?'|'@'|'A'|'B'|'C'|'D'|'E'|'F'|'G'|'H'|'I'|'J'|'K'|'L'|'M'|'N'|'O'|'P'|'Q'|'R'|'S'|'T'|'U'|'V'|'W'|'X'|'Y'|'Z'|'['|'\\\\'|']'|'^'|'_'|'`'|'a'|'b'|'c'|'d'|'e'|'f'|'g'|'h'|'i'|'j'|'k'|'l'|'m'|'n'|'o'|'p'|'q'|'r'|'s'|'t'|'u'|'v'|'w'|'x'|'y'|'z'|'{'|'|'|'}'
<string_var> ::= 's0'|'s1'|'s2'|'in0'
<string_slice> ::= <string>'['<int>':'<int>']'|<string>'[:'<int>']'|<string>'['<int>':]'|<string>'[1:]'|<string>'[:1]'
<string_literal> ::= ''|'\\n'|'\\t'|' '|'!'|'""'|'#'|'$'|'%'|'&'|""\\'""|'('|')'|'*'|'+'|','|'-'|'.'|'/'|'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|':'|';'|'<'|'='|'>'|'?'|'@'|'A'|'B'|'C'|'D'|'E'|'F'|'G'|'H'|'I'|'J'|'K'|'L'|'M'|'N'|'O'|'P'|'Q'|'R'|'S'|'T'|'U'|'V'|'W'|'X'|'Y'|'Z'|'['|'\\\\'|']'|'^'|'_'|'`'|'a'|'b'|'c'|'d'|'e'|'f'|'g'|'h'|'i'|'j'|'k'|'l'|'m'|'n'|'o'|'p'|'q'|'r'|'s'|'t'|'u'|'v'|'w'|'x'|'y'|'z'|'{'|'|'|'}'
"
Digits,"Given an integer, return that integer’s digits each on their own in a list starting with the most significant digit. A negative integer should have the negative sign append with the least significant digit.","Write a python function using given grammar without comment, explanation, example usage. Function parameter name has to be in0, in1...(depends on how many parameter it needs), and return variable name has to be res0, res1...(depends on how many parameter it needs).
problem description: Given an integer, return that integer’s digits each on their own in a list starting with the least significant digit. A negative integer should have the negative sign append with the most significant digit.
problem grammar: <predefined> ::= ""i0 = int(); i1 = int(); i2 = int()""
""b0 = bool(); b1 = bool(); b2 = bool()""
""s0 = str(); s1 = str(); s2 = str()""
""c0 = ' '; c1 = ' '; c2 = ' '""
""li0 = []; li1 = []; li2 = []""
""res0 = []""
""if 'rec_counter' not in globals():{:""
""globals()['rec_counter'] = 0:}""
""global rec_counter""
<code>
<code> ::= <code><statement>'\n'|<statement>'\n'<code>|<code><statement>'\n'<code>|<statement>'\n'
<statement> ::= <simple_stmt>|<compound_stmt>|'return [0]'
<simple_stmt> ::= <call>|<assign>
<compound_stmt> ::= <for>|<if>|'loopBreak% = 0\nwhile '<bool>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<call> ::= <list_int_var>'.append('<int>')'|<list_int_var>'.insert('<int>','<int>')'|<list_int_var>'.insert(0,'<int>')'|'deleteListItem('<list_int>', '<int>')'|'setListIndexTo('<list_int>', '<int>', '<int>')'|'if rec_counter < 900 and not stop.value:{:'
'rec_counter += 1'
<list_int_var>' = evolve('<int>')'
'rec_counter -= 1'
':}'|'return res0'
<assign> ::= <bool_var>' = '<bool>|<int_assign>|<char_var>' = '<char>|<string_var>' = '<string>|<list_int_var>' = '<list_int>
<for> ::= 'loopBreak% = 0\nfor forCounter% in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in '<string>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<char_var>' in '<string>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in '<string>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in '<string>'.strip().split():{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in saveSplit('<string>'.strip(), '<string>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in '<list_int>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in '<list_int>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<number> ::= <number><num>|<num><number>|<number><num><number>|<num>
<num> ::= '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
<comp_op> ::= '<'|'>'|'=='|'>='|'<='|'!='|'is'|'is not'
<string_const_part> ::= <string_const_part><string_literal>|<string_literal><string_const_part>|<string_const_part><string_literal><string_const_part>|<string_literal>
<in_list_comp_op> ::= 'in'|'not in'
<list_comp_op> ::= '=='|'!='
<bool_var> ::= 'b0'|'b1'|'b2'
<bool> ::= <bool_var>|<bool_const>|'(not '<bool>')'|'('<bool>' '<bool_op>' '<bool>')'|'( not '<bool>' and '<bool>')'|'('<bool>' and not '<bool>')'|'('<int>' '<comp_op>' '<int>')'|'bool('<int>')'|<char>'.isdigit()'|<char>'.isspace()'|<char>'.isalpha()'|'('<char>' == '<char>')'|'('<string>' in '<string>')'|'('<string>' not in '<string>')'|'('<string>' == '<string>')'|'('<string>' != '<string>')'|<string>'.startswith('<string>')'|<string>'.endswith('<string>')'|'(not '<string>')'|'('<int>' '<in_list_comp_op>' '<list_int>')'|'('<list_int>' '<list_comp_op>' '<list_int>')'|'('<list_int>' == [])'
<bool_op> ::= 'and'|'or'|'^'|'=='
<bool_const> ::= 'True'|'False'
<if> ::= 'if '<bool>':{:\n'<code>':}'|'if '<bool>':{:\n'<code>':}else:{:\n'<code>':}'
<int> ::= 'int('<bool>')'|<int_var>|'int('<number>'.0)'|<arith_prefix><int>|'( '<int>' '<arith_ops>' '<int>' )'|<int_arith_ops_protected>'('<int>','<int>')'|'min('<int>', '<int>')'|'max('<int>', '<int>')'|'abs('<int>')'|'('<int>' + 1)'|'('<int>' - 1)'|'ord('<char>')'|'len('<string>')'|<string>'.count('<char>')'|<string>'.count('<string>')'|'getIndexIntList('<list_int>', '<int>')'|'len('<list_int>')'|'getIndexIntList('<list_int>', 0)'|'getIndexIntList('<list_int>', -1)'|'saveIndex('<list_int>', '<int>')'|<list_int>'.count('<int>')'
<string> ::= 'str('<bool>')'|'str('<int>')'|<char>|<string_var>|""'""<string_const_part>""'""|<string_slice>|'('<string>' + '<string>')'|<string>'.lstrip()'|<string>'.rstrip()'|<string>'.strip()'|<string>'.lstrip('<string>')'|<string>'.rstrip('<string>')'|<string>'.strip('<string>')'|<string>'.capitalize()'|""''.join(reversed(""<string>'))'|<string>'.replace('<string>','<string>', 1)'|<string>'.replace('<string>','<string>')'|<string>'.replace('<char>','<char>', 1)'|<string>'.replace('<char>','<char>')'|<string>'.replace('<char>',"""")'|'setchar('<string>','<char>','<int>')'
<int_var> ::= 'i0'|'i1'|'i2'|'in0'
<int_assign> ::= <int_var>' = '<int>|<int_var>' '<arith_ops>'= '<int>
<arith_ops> ::= '+'|'-'|'*'
<int_arith_ops_protected> ::= 'divInt'|'mod'
<arith_prefix> ::= '+'|'-'
<char> ::= 'int_to_chr('<int>')'|<char_var>|""'""<char_literal>""'""|'getCharFromString('<string>', '<int>')'
<char_var> ::= 'c0'|'c1'|'c2'
<char_literal> ::= '\\n'|'\\t'|' '|'!'|'""'|'#'|'$'|'%'|'&'|""\\'""|'('|')'|'*'|'+'|','|'-'|'.'|'/'|'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|':'|';'|'<'|'='|'>'|'?'|'@'|'A'|'B'|'C'|'D'|'E'|'F'|'G'|'H'|'I'|'J'|'K'|'L'|'M'|'N'|'O'|'P'|'Q'|'R'|'S'|'T'|'U'|'V'|'W'|'X'|'Y'|'Z'|'['|'\\\\'|']'|'^'|'_'|'`'|'a'|'b'|'c'|'d'|'e'|'f'|'g'|'h'|'i'|'j'|'k'|'l'|'m'|'n'|'o'|'p'|'q'|'r'|'s'|'t'|'u'|'v'|'w'|'x'|'y'|'z'|'{'|'|'|'}'
<string_var> ::= 's0'|'s1'|'s2'
<string_slice> ::= <string>'['<int>':'<int>']'|<string>'[:'<int>']'|<string>'['<int>':]'|<string>'[1:]'|<string>'[:1]'
<string_literal> ::= ''|'\\n'|'\\t'|' '|'!'|'""'|'#'|'$'|'%'|'&'|""\\'""|'('|')'|'*'|'+'|','|'-'|'.'|'/'|'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|':'|';'|'<'|'='|'>'|'?'|'@'|'A'|'B'|'C'|'D'|'E'|'F'|'G'|'H'|'I'|'J'|'K'|'L'|'M'|'N'|'O'|'P'|'Q'|'R'|'S'|'T'|'U'|'V'|'W'|'X'|'Y'|'Z'|'['|'\\\\'|']'|'^'|'_'|'`'|'a'|'b'|'c'|'d'|'e'|'f'|'g'|'h'|'i'|'j'|'k'|'l'|'m'|'n'|'o'|'p'|'q'|'r'|'s'|'t'|'u'|'v'|'w'|'x'|'y'|'z'|'{'|'|'|'}'
<list_int_var> ::= 'li0'|'li1'|'li2'|'res0'
<list_int> ::= <list_int_var>|'list(saveRange('<int>','<int>'))'|<list_int_slice>|'list(reversed('<list_int>'))'|'[x if x == '<int>' else '<int>' for x in '<list_int>']'|'replaceFirstElementInList('<list_int>','<int>','<int>')'|'[x for x in '<list_int>' if x == '<int>']'
<list_int_slice> ::= <list_int>'['<int>':'<int>']'|<list_int>'[:'<int>']'|<list_int>'['<int>':]'|<list_int>'[1:]'|<list_int>'[:1]'
"
Grade,"Given 5 integers, the first four represent the lower numeric thresholds for achieving an A, B, C, and D, and will be distinct and in descending order. The fifth represents the student’s numeric grade. The program return X, where X is A, B, C, D, or F depending on the thresholds and the numeric grade.","Write a python function using given grammar without comment, explanation, example usage. Function parameter name has to be in0, in1...(depends on how many parameter it needs), and return variable name has to be res0, res1...(depends on how many parameter it needs).
problem description: Given 5 integers, the first four represent the lower numeric thresholds for achieving an A, B, C, and D, and will be distinct and in descending order. The fifth represents the student’s numeric grade. The program return X, where X is A, B, C, D, or F depending on the thresholds and the numeric grade.
problem grammar: <predefined> ::= ""i0 = int(); i1 = int(); i2 = int()""
""b0 = bool(); b1 = bool(); b2 = bool()""
""s0 = str(); s1 = str(); s2 = str()""
""res0 = str()""
""if 'rec_counter' not in globals():{:""
""globals()['rec_counter'] = 0:}""
""global rec_counter""
<code>
<code> ::= <code><statement>'\n'|<statement>'\n'<code>|<code><statement>'\n'<code>|<statement>'\n'
<statement> ::= <simple_stmt>|<compound_stmt>
<simple_stmt> ::= <call>|<assign>
<compound_stmt> ::= <for>|<if>|'loopBreak% = 0\nwhile '<bool>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<call> ::= 'if rec_counter < 900 and not stop.value:{:'
'rec_counter += 1'
<string_var>' = evolve('<int>', '<int>', '<int>', '<int>', '<int>')'
'rec_counter -= 1'
':}'|'return res0'
<assign> ::= <bool_var>' = '<bool>|<int_assign>|<string_var>' = '<string>
<for> ::= 'loopBreak% = 0\nfor forCounter% in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in '<string>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in '<string>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in '<string>'.strip().split():{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in saveSplit('<string>'.strip(), '<string>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<number> ::= <number><num>|<num><number>|<number><num><number>|<num>
<num> ::= '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
<comp_op> ::= '<'|'>'|'=='|'>='|'<='|'!='|'is'|'is not'
<string_literal> ::= 'A'|'B'|'C'|'D'|'F'
<bool_var> ::= 'b0'|'b1'|'b2'
<bool> ::= <bool_var>|<bool_const>|'(not '<bool>')'|'('<bool>' '<bool_op>' '<bool>')'|'( not '<bool>' and '<bool>')'|'('<bool>' and not '<bool>')'|'('<int>' '<comp_op>' '<int>')'|'bool('<int>')'|'('<string>' in '<string>')'|'('<string>' not in '<string>')'|'('<string>' == '<string>')'|'('<string>' != '<string>')'|<string>'.startswith('<string>')'|<string>'.endswith('<string>')'|'(not '<string>')'
<bool_op> ::= 'and'|'or'|'^'|'=='
<bool_const> ::= 'True'|'False'
<if> ::= 'if '<bool>':{:\n'<code>':}'|'if '<bool>':{:\n'<code>':}else:{:\n'<code>':}'
<int> ::= 'int('<bool>')'|<int_var>|'int('<number>'.0)'|<arith_prefix><int>|'( '<int>' '<arith_ops>' '<int>' )'|<int_arith_ops_protected>'('<int>','<int>')'|'min('<int>', '<int>')'|'max('<int>', '<int>')'|'abs('<int>')'|'('<int>' + 1)'|'('<int>' - 1)'|'len('<string>')'|<string>'.count('<char>')'|<string>'.count('<string>')'
<string> ::= 'str('<bool>')'|'str('<int>')'|<string_var>|""'""<string_literal>""'""|<string_slice>|'('<string>' + '<string>')'|<string>'.lstrip()'|<string>'.rstrip()'|<string>'.strip()'|<string>'.lstrip('<string>')'|<string>'.rstrip('<string>')'|<string>'.strip('<string>')'|<string>'.capitalize()'|""''.join(reversed(""<string>'))'|<string>'.replace('<string>','<string>', 1)'|<string>'.replace('<string>','<string>')'|<string>'.replace('<char>','<char>', 1)'|<string>'.replace('<char>','<char>')'|<string>'.replace('<char>',"""")'|'setchar('<string>','<char>','<int>')'
<int_var> ::= 'i0'|'i1'|'i2'|'in0'|'in1'|'in2'|'in3'|'in4'
<int_assign> ::= <int_var>' = '<int>|<int_var>' '<arith_ops>'= '<int>
<arith_ops> ::= '+'|'-'|'*'
<int_arith_ops_protected> ::= 'divInt'|'mod'
<arith_prefix> ::= '+'|'-'
<char> ::= 'int_to_chr('<int>')'|'getCharFromString('<string>', '<int>')'
<string_var> ::= 's0'|'s1'|'s2'|'res0'
<string_slice> ::= <string>'['<int>':'<int>']'|<string>'[:'<int>']'|<string>'['<int>':]'|<string>'[1:]'|<string>'[:1]'
"
Median,"Given 3 integers, return their median.","Write a python function using given grammar without comment, explanation, example usage. Function parameter name has to be in0, in1...(depends on how many parameter it needs), and return variable name has to be res0, res1...(depends on how many parameter it needs).
problem description: Given 3 integers, return their median.
problem grammar: <predefined> ::= ""i0 = int(); i1 = int(); i2 = int()""
""b0 = bool(); b1 = bool(); b2 = bool()""
""res0 = int()""
""if 'rec_counter' not in globals():{:""
""globals()['rec_counter'] = 0:}""
""global rec_counter""
<code>
<code> ::= <code><statement>'\n'|<statement>'\n'<code>|<code><statement>'\n'<code>|<statement>'\n'
<statement> ::= <simple_stmt>|<compound_stmt>
<simple_stmt> ::= <call>|<assign>
<compound_stmt> ::= <for>|<if>|'loopBreak% = 0\nwhile '<bool>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<call> ::= 'if rec_counter < 900 and not stop.value:{:'
'rec_counter += 1'
<int_var>' = evolve('<int>', '<int>', '<int>')'
'rec_counter -= 1'
':}'|'return res0'
<assign> ::= <bool_var>' = '<bool>|<int_assign>
<for> ::= 'loopBreak% = 0\nfor forCounter% in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<number> ::= <number><num>|<num><number>|<number><num><number>|<num>
<num> ::= '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
<comp_op> ::= '<'|'>'|'=='|'>='|'<='|'!='|'is'|'is not'
<bool_var> ::= 'b0'|'b1'|'b2'
<bool> ::= <bool_var>|<bool_const>|'(not '<bool>')'|'('<bool>' '<bool_op>' '<bool>')'|'( not '<bool>' and '<bool>')'|'('<bool>' and not '<bool>')'|'('<int>' '<comp_op>' '<int>')'|'bool('<int>')'
<bool_op> ::= 'and'|'or'|'^'|'=='
<bool_const> ::= 'True'|'False'
<if> ::= 'if '<bool>':{:\n'<code>':}'|'if '<bool>':{:\n'<code>':}else:{:\n'<code>':}'
<int> ::= 'int('<bool>')'|<int_var>|'int('<number>'.0)'|<arith_prefix><int>|'( '<int>' '<arith_ops>' '<int>' )'|<int_arith_ops_protected>'('<int>','<int>')'|'min('<int>', '<int>')'|'max('<int>', '<int>')'|'abs('<int>')'|'('<int>' + 1)'|'('<int>' - 1)'
<int_var> ::= 'i0'|'i1'|'i2'|'res0'|'in0'|'in1'|'in2'
<int_assign> ::= <int_var>' = '<int>|<int_var>' '<arith_ops>'= '<int>
<arith_ops> ::= '+'|'-'|'*'
<int_arith_ops_protected> ::= 'divInt'|'mod'
<arith_prefix> ::= '+'|'-'
"
Smallest,"Given 4 integers, return the smallest of them.","Write a python function using given grammar without comment, explanation, example usage. Function parameter name has to be in0, in1...(depends on how many parameter it needs), and return variable name has to be res0, res1...(depends on how many parameter it needs).
problem description: Given 4 integers, return the smallest of them.
problem grammar: <predefined> ::= ""i0 = int(); i1 = int(); i2 = int()""
""b0 = bool(); b1 = bool(); b2 = bool()""
""res0 = int()""
""if 'rec_counter' not in globals():{:""
""globals()['rec_counter'] = 0:}""
""global rec_counter""
<code>
<code> ::= <code><statement>'\n'|<statement>'\n'<code>|<code><statement>'\n'<code>|<statement>'\n'
<statement> ::= <simple_stmt>|<compound_stmt>
<simple_stmt> ::= <call>|<assign>
<compound_stmt> ::= <for>|<if>|'loopBreak% = 0\nwhile '<bool>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<call> ::= 'if rec_counter < 900 and not stop.value:{:'
'rec_counter += 1'
<int_var>' = evolve('<int>', '<int>', '<int>', '<int>')'
'rec_counter -= 1'
':}'|'return res0'
<assign> ::= <bool_var>' = '<bool>|<int_assign>
<for> ::= 'loopBreak% = 0\nfor forCounter% in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<number> ::= <number><num>|<num><number>|<number><num><number>|<num>
<num> ::= '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
<comp_op> ::= '<'|'>'|'=='|'>='|'<='|'!='|'is'|'is not'
<bool_var> ::= 'b0'|'b1'|'b2'
<bool> ::= <bool_var>|<bool_const>|'(not '<bool>')'|'('<bool>' '<bool_op>' '<bool>')'|'( not '<bool>' and '<bool>')'|'('<bool>' and not '<bool>')'|'('<int>' '<comp_op>' '<int>')'|'bool('<int>')'
<bool_op> ::= 'and'|'or'|'^'|'=='
<bool_const> ::= 'True'|'False'
<if> ::= 'if '<bool>':{:\n'<code>':}'|'if '<bool>':{:\n'<code>':}else:{:\n'<code>':}'
<int> ::= 'int('<bool>')'|<int_var>|'int('<number>'.0)'|<arith_prefix><int>|'( '<int>' '<arith_ops>' '<int>' )'|<int_arith_ops_protected>'('<int>','<int>')'|'min('<int>', '<int>')'|'max('<int>', '<int>')'|'abs('<int>')'|'('<int>' + 1)'|'('<int>' - 1)'
<int_var> ::= 'i0'|'i1'|'i2'|'res0'|'in0'|'in1'|'in2'|'in3'
<int_assign> ::= <int_var>' = '<int>|<int_var>' '<arith_ops>'= '<int>
<arith_ops> ::= '+'|'-'|'*'
<int_arith_ops_protected> ::= 'divInt'|'mod'
<arith_prefix> ::= '+'|'-'

"
Syllables,"Given a string containing symbols, spaces, digits, and lowercase letters, count the number of occurrences of vowels (a, e, i, o, u, y) in the string and return that number.","Write a python function using given grammar without comment, explanation, example usage. Function parameter name has to be in0, in1...(depends on how many parameter it needs), and return variable name has to be res0, res1...(depends on how many parameter it needs).
problem description: Given a string containing symbols, spaces, digits, and lowercase letters, count the number of occurrences of vowels (a, e, i, o, u, y) in the string and return that number.
problem grammar: <predefined> ::= ""i0 = int(); i1 = int(); i2 = int()""
""b0 = bool(); b1 = bool(); b2 = bool()""
""s0 = str(); s1 = str(); s2 = str()""
""c0 = ' '; c1 = ' '; c2 = ' '""
""res0 = int()""
""if 'rec_counter' not in globals():{:""
""globals()['rec_counter'] = 0:}""
""global rec_counter""
<code>
<code> ::= <code><statement>'\n'|<statement>'\n'<code>|<code><statement>'\n'<code>|<statement>'\n'
<statement> ::= <simple_stmt>|<compound_stmt>
<simple_stmt> ::= <call>|<assign>
<compound_stmt> ::= <for>|<if>|'loopBreak% = 0\nwhile '<bool>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<call> ::= 'if rec_counter < 900 and not stop.value:{:'
'rec_counter += 1'
<int_var>' = evolve('<string>')'
'rec_counter -= 1'
':}'|'return res0'
<assign> ::= <bool_var>' = '<bool>|<int_assign>|<char_var>' = '<char>|<string_var>' = '<string>
<for> ::= 'loopBreak% = 0\nfor forCounter% in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange(0, '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<int_var>' in saveRange('<int>', '<int>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor forCounter% in '<string>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<char_var>' in '<string>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in '<string>':{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in '<string>'.strip().split():{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'|'loopBreak% = 0\nfor '<string_var>' in saveSplit('<string>'.strip(), '<string>'):{:\n'<code>'\nif loopBreak% > loopBreakConst or stop.value:{:\nbreak\n:}loopBreak% += 1\n:}'
<number> ::= <number><num>|<num><number>|<number><num><number>|<num>
<num> ::= '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
<comp_op> ::= '<'|'>'|'=='|'>='|'<='|'!='|'is'|'is not'
<string_const_part> ::= <string_const_part><string_literal>|<string_literal><string_const_part>|<string_const_part><string_literal><string_const_part>|<string_literal>
<bool_var> ::= 'b0'|'b1'|'b2'
<bool> ::= <bool_var>|<bool_const>|'(not '<bool>')'|'('<bool>' '<bool_op>' '<bool>')'|'( not '<bool>' and '<bool>')'|'('<bool>' and not '<bool>')'|'('<int>' '<comp_op>' '<int>')'|'bool('<int>')'|<char>'.isdigit()'|<char>'.isspace()'|<char>'.isalpha()'|'('<char>' == '<char>')'|'('<string>' in '<string>')'|'('<string>' not in '<string>')'|'('<string>' == '<string>')'|'('<string>' != '<string>')'|<string>'.startswith('<string>')'|<string>'.endswith('<string>')'|'(not '<string>')'
<bool_op> ::= 'and'|'or'|'^'|'=='
<bool_const> ::= 'True'|'False'
<if> ::= 'if '<bool>':{:\n'<code>':}'|'if '<bool>':{:\n'<code>':}else:{:\n'<code>':}'
<int> ::= 'int('<bool>')'|<int_var>|'int('<number>'.0)'|<arith_prefix><int>|'( '<int>' '<arith_ops>' '<int>' )'|<int_arith_ops_protected>'('<int>','<int>')'|'min('<int>', '<int>')'|'max('<int>', '<int>')'|'abs('<int>')'|'('<int>' + 1)'|'('<int>' - 1)'|'ord('<char>')'|'len('<string>')'|<string>'.count('<char>')'|<string>'.count('<string>')'
<string> ::= 'str('<bool>')'|'str('<int>')'|<char>|<string_var>|<string_const>|<string_slice>|'('<string>' + '<string>')'|<string>'.lstrip()'|<string>'.rstrip()'|<string>'.strip()'|<string>'.lstrip('<string>')'|<string>'.rstrip('<string>')'|<string>'.strip('<string>')'|<string>'.capitalize()'|""''.join(reversed(""<string>'))'|<string>'.replace('<string>','<string>', 1)'|<string>'.replace('<string>','<string>')'|<string>'.replace('<char>','<char>', 1)'|<string>'.replace('<char>','<char>')'|<string>'.replace('<char>',"""")'|'setchar('<string>','<char>','<int>')'
<int_var> ::= 'i0'|'i1'|'i2'|'res0'
<int_assign> ::= <int_var>' = '<int>|<int_var>' '<arith_ops>'= '<int>
<arith_ops> ::= '+'|'-'|'*'
<int_arith_ops_protected> ::= 'divInt'|'mod'
<arith_prefix> ::= '+'|'-'
<char> ::= 'int_to_chr('<int>')'|<char_var>|""'""<char_literal>""'""|'getCharFromString('<string>', '<int>')'
<char_var> ::= 'c0'|'c1'|'c2'
<char_literal> ::= '\\n'|'\\t'|' '|'!'|'""'|'#'|'$'|'%'|'&'|""\\'""|'('|')'|'*'|'+'|','|'-'|'.'|'/'|'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|':'|';'|'<'|'='|'>'|'?'|'@'|'A'|'B'|'C'|'D'|'E'|'F'|'G'|'H'|'I'|'J'|'K'|'L'|'M'|'N'|'O'|'P'|'Q'|'R'|'S'|'T'|'U'|'V'|'W'|'X'|'Y'|'Z'|'['|'\\\\'|']'|'^'|'_'|'`'|'a'|'b'|'c'|'d'|'e'|'f'|'g'|'h'|'i'|'j'|'k'|'l'|'m'|'n'|'o'|'p'|'q'|'r'|'s'|'t'|'u'|'v'|'w'|'x'|'y'|'z'|'{'|'|'|'}'
<string_var> ::= 's0'|'s1'|'s2'|'in0'
<string_slice> ::= <string>'['<int>':'<int>']'|<string>'[:'<int>']'|<string>'['<int>':]'|<string>'[1:]'|<string>'[:1]'
<string_const> ::= ""'""<string_const_part>""'""|""'aeiouy'""
<string_literal> ::= ''|'\\n'|'\\t'|' '|'!'|'""'|'#'|'$'|'%'|'&'|""\\'""|'('|')'|'*'|'+'|','|'-'|'.'|'/'|'0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'|':'|';'|'<'|'='|'>'|'?'|'@'|'A'|'B'|'C'|'D'|'E'|'F'|'G'|'H'|'I'|'J'|'K'|'L'|'M'|'N'|'O'|'P'|'Q'|'R'|'S'|'T'|'U'|'V'|'W'|'X'|'Y'|'Z'|'['|'\\\\'|']'|'^'|'_'|'`'|'a'|'b'|'c'|'d'|'e'|'f'|'g'|'h'|'i'|'j'|'k'|'l'|'m'|'n'|'o'|'p'|'q'|'r'|'s'|'t'|'u'|'v'|'w'|'x'|'y'|'z'|'{'|'|'|'}'|'a'|'e'|'i'|'o'|'u'|'y'
"
